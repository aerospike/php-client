// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0-devel
// 	protoc        v3.12.4
// source: asld_kvs.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Server particle types. Unsupported types are commented out.
type ParticleType int32

const (
	ParticleType_ParticleTypeNull    ParticleType = 0
	ParticleType_ParticleTypeInteger ParticleType = 1
	ParticleType_ParticleTypeFloat   ParticleType = 2
	ParticleType_ParticleTypeString  ParticleType = 3
	ParticleType_ParticleTypeBlob    ParticleType = 4
	ParticleType_ParticleTypeDigest  ParticleType = 6
	ParticleType_ParticleTypeBool    ParticleType = 17
	ParticleType_ParticleTypeHLL     ParticleType = 18
	ParticleType_ParticleTypeMap     ParticleType = 19
	ParticleType_ParticleTypeList    ParticleType = 20
	ParticleType_ParticleTypeLDT     ParticleType = 21
	ParticleType_ParticleTypeGeoJson ParticleType = 23
)

// Enum value maps for ParticleType.
var (
	ParticleType_name = map[int32]string{
		0:  "ParticleTypeNull",
		1:  "ParticleTypeInteger",
		2:  "ParticleTypeFloat",
		3:  "ParticleTypeString",
		4:  "ParticleTypeBlob",
		6:  "ParticleTypeDigest",
		17: "ParticleTypeBool",
		18: "ParticleTypeHLL",
		19: "ParticleTypeMap",
		20: "ParticleTypeList",
		21: "ParticleTypeLDT",
		23: "ParticleTypeGeoJson",
	}
	ParticleType_value = map[string]int32{
		"ParticleTypeNull":    0,
		"ParticleTypeInteger": 1,
		"ParticleTypeFloat":   2,
		"ParticleTypeString":  3,
		"ParticleTypeBlob":    4,
		"ParticleTypeDigest":  6,
		"ParticleTypeBool":    17,
		"ParticleTypeHLL":     18,
		"ParticleTypeMap":     19,
		"ParticleTypeList":    20,
		"ParticleTypeLDT":     21,
		"ParticleTypeGeoJson": 23,
	}
)

func (x ParticleType) Enum() *ParticleType {
	p := new(ParticleType)
	*p = x
	return p
}

func (x ParticleType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ParticleType) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[0].Descriptor()
}

func (ParticleType) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[0]
}

func (x ParticleType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ParticleType.Descriptor instead.
func (ParticleType) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{0}
}

type ExpType int32

const (
	ExpType_ExpTypeNil    ExpType = 0
	ExpType_ExpTypeBool   ExpType = 1
	ExpType_ExpTypeInt    ExpType = 2
	ExpType_ExpTypeString ExpType = 3
	ExpType_ExpTypeList   ExpType = 4
	ExpType_ExpTypeMap    ExpType = 5
	ExpType_ExpTypeBlob   ExpType = 6
	ExpType_ExpTypeFloat  ExpType = 7
	ExpType_ExpTypeGeo    ExpType = 8
	ExpType_ExpTypeHll    ExpType = 9
)

// Enum value maps for ExpType.
var (
	ExpType_name = map[int32]string{
		0: "ExpTypeNil",
		1: "ExpTypeBool",
		2: "ExpTypeInt",
		3: "ExpTypeString",
		4: "ExpTypeList",
		5: "ExpTypeMap",
		6: "ExpTypeBlob",
		7: "ExpTypeFloat",
		8: "ExpTypeGeo",
		9: "ExpTypeHll",
	}
	ExpType_value = map[string]int32{
		"ExpTypeNil":    0,
		"ExpTypeBool":   1,
		"ExpTypeInt":    2,
		"ExpTypeString": 3,
		"ExpTypeList":   4,
		"ExpTypeMap":    5,
		"ExpTypeBlob":   6,
		"ExpTypeFloat":  7,
		"ExpTypeGeo":    8,
		"ExpTypeHll":    9,
	}
)

func (x ExpType) Enum() *ExpType {
	p := new(ExpType)
	*p = x
	return p
}

func (x ExpType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExpType) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[1].Descriptor()
}

func (ExpType) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[1]
}

func (x ExpType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExpType.Descriptor instead.
func (ExpType) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{1}
}

type ExpOp int32

const (
	ExpOp_ExpOpUnknown      ExpOp = 0
	ExpOp_ExpOpEq           ExpOp = 1
	ExpOp_ExpOpNe           ExpOp = 2
	ExpOp_ExpOpGt           ExpOp = 3
	ExpOp_ExpOpGe           ExpOp = 4
	ExpOp_ExpOpLt           ExpOp = 5
	ExpOp_ExpOpLe           ExpOp = 6
	ExpOp_ExpOpRegex        ExpOp = 7
	ExpOp_ExpOpGeo          ExpOp = 8
	ExpOp_ExpOpAnd          ExpOp = 16
	ExpOp_ExpOpOr           ExpOp = 17
	ExpOp_ExpOpNot          ExpOp = 18
	ExpOp_ExpOpExclusive    ExpOp = 19
	ExpOp_ExpOpAdd          ExpOp = 20
	ExpOp_ExpOpSub          ExpOp = 21
	ExpOp_ExpOpMul          ExpOp = 22
	ExpOp_ExpOpDiv          ExpOp = 23
	ExpOp_ExpOpPow          ExpOp = 24
	ExpOp_ExpOpLog          ExpOp = 25
	ExpOp_ExpOpMod          ExpOp = 26
	ExpOp_ExpOpAbs          ExpOp = 27
	ExpOp_ExpOpFloor        ExpOp = 28
	ExpOp_ExpOpCeil         ExpOp = 29
	ExpOp_ExpOpToInt        ExpOp = 30
	ExpOp_ExpOpToFloat      ExpOp = 31
	ExpOp_ExpOpIntAnd       ExpOp = 32
	ExpOp_ExpOpIntOr        ExpOp = 33
	ExpOp_ExpOpIntXor       ExpOp = 34
	ExpOp_ExpOpIntNot       ExpOp = 35
	ExpOp_ExpOpIntLShift    ExpOp = 36
	ExpOp_ExpOpIntRShift    ExpOp = 37
	ExpOp_ExpOpIntARShift   ExpOp = 38
	ExpOp_ExpOpIntCount     ExpOp = 39
	ExpOp_ExpOpIntLScan     ExpOp = 40
	ExpOp_ExpOpIntRScan     ExpOp = 41
	ExpOp_ExpOpMin          ExpOp = 50
	ExpOp_ExpOpMax          ExpOp = 51
	ExpOp_ExpOpDigestModulo ExpOp = 64
	ExpOp_ExpOpDeviceSize   ExpOp = 65
	ExpOp_ExpOpLastUpdate   ExpOp = 66
	ExpOp_ExpOpSinceUpdate  ExpOp = 67
	ExpOp_ExpOpVoidTime     ExpOp = 68
	ExpOp_ExpOpTtl          ExpOp = 69
	ExpOp_ExpOpSetName      ExpOp = 70
	ExpOp_ExpOpKeyExists    ExpOp = 71
	ExpOp_ExpOpIsTombstone  ExpOp = 72
	ExpOp_ExpOpMemorySize   ExpOp = 73
	ExpOp_ExpOpRecordSize   ExpOp = 74
	ExpOp_ExpOpKey          ExpOp = 80
	ExpOp_ExpOpBin          ExpOp = 81
	ExpOp_ExpOpBinType      ExpOp = 82
	ExpOp_ExpOpCond         ExpOp = 123
	ExpOp_ExpOpVar          ExpOp = 124
	ExpOp_ExpOpLet          ExpOp = 125
	ExpOp_ExpOpQuoted       ExpOp = 126
	ExpOp_ExpOpCall         ExpOp = 127
)

// Enum value maps for ExpOp.
var (
	ExpOp_name = map[int32]string{
		0:   "ExpOpUnknown",
		1:   "ExpOpEq",
		2:   "ExpOpNe",
		3:   "ExpOpGt",
		4:   "ExpOpGe",
		5:   "ExpOpLt",
		6:   "ExpOpLe",
		7:   "ExpOpRegex",
		8:   "ExpOpGeo",
		16:  "ExpOpAnd",
		17:  "ExpOpOr",
		18:  "ExpOpNot",
		19:  "ExpOpExclusive",
		20:  "ExpOpAdd",
		21:  "ExpOpSub",
		22:  "ExpOpMul",
		23:  "ExpOpDiv",
		24:  "ExpOpPow",
		25:  "ExpOpLog",
		26:  "ExpOpMod",
		27:  "ExpOpAbs",
		28:  "ExpOpFloor",
		29:  "ExpOpCeil",
		30:  "ExpOpToInt",
		31:  "ExpOpToFloat",
		32:  "ExpOpIntAnd",
		33:  "ExpOpIntOr",
		34:  "ExpOpIntXor",
		35:  "ExpOpIntNot",
		36:  "ExpOpIntLShift",
		37:  "ExpOpIntRShift",
		38:  "ExpOpIntARShift",
		39:  "ExpOpIntCount",
		40:  "ExpOpIntLScan",
		41:  "ExpOpIntRScan",
		50:  "ExpOpMin",
		51:  "ExpOpMax",
		64:  "ExpOpDigestModulo",
		65:  "ExpOpDeviceSize",
		66:  "ExpOpLastUpdate",
		67:  "ExpOpSinceUpdate",
		68:  "ExpOpVoidTime",
		69:  "ExpOpTtl",
		70:  "ExpOpSetName",
		71:  "ExpOpKeyExists",
		72:  "ExpOpIsTombstone",
		73:  "ExpOpMemorySize",
		74:  "ExpOpRecordSize",
		80:  "ExpOpKey",
		81:  "ExpOpBin",
		82:  "ExpOpBinType",
		123: "ExpOpCond",
		124: "ExpOpVar",
		125: "ExpOpLet",
		126: "ExpOpQuoted",
		127: "ExpOpCall",
	}
	ExpOp_value = map[string]int32{
		"ExpOpUnknown":      0,
		"ExpOpEq":           1,
		"ExpOpNe":           2,
		"ExpOpGt":           3,
		"ExpOpGe":           4,
		"ExpOpLt":           5,
		"ExpOpLe":           6,
		"ExpOpRegex":        7,
		"ExpOpGeo":          8,
		"ExpOpAnd":          16,
		"ExpOpOr":           17,
		"ExpOpNot":          18,
		"ExpOpExclusive":    19,
		"ExpOpAdd":          20,
		"ExpOpSub":          21,
		"ExpOpMul":          22,
		"ExpOpDiv":          23,
		"ExpOpPow":          24,
		"ExpOpLog":          25,
		"ExpOpMod":          26,
		"ExpOpAbs":          27,
		"ExpOpFloor":        28,
		"ExpOpCeil":         29,
		"ExpOpToInt":        30,
		"ExpOpToFloat":      31,
		"ExpOpIntAnd":       32,
		"ExpOpIntOr":        33,
		"ExpOpIntXor":       34,
		"ExpOpIntNot":       35,
		"ExpOpIntLShift":    36,
		"ExpOpIntRShift":    37,
		"ExpOpIntARShift":   38,
		"ExpOpIntCount":     39,
		"ExpOpIntLScan":     40,
		"ExpOpIntRScan":     41,
		"ExpOpMin":          50,
		"ExpOpMax":          51,
		"ExpOpDigestModulo": 64,
		"ExpOpDeviceSize":   65,
		"ExpOpLastUpdate":   66,
		"ExpOpSinceUpdate":  67,
		"ExpOpVoidTime":     68,
		"ExpOpTtl":          69,
		"ExpOpSetName":      70,
		"ExpOpKeyExists":    71,
		"ExpOpIsTombstone":  72,
		"ExpOpMemorySize":   73,
		"ExpOpRecordSize":   74,
		"ExpOpKey":          80,
		"ExpOpBin":          81,
		"ExpOpBinType":      82,
		"ExpOpCond":         123,
		"ExpOpVar":          124,
		"ExpOpLet":          125,
		"ExpOpQuoted":       126,
		"ExpOpCall":         127,
	}
)

func (x ExpOp) Enum() *ExpOp {
	p := new(ExpOp)
	*p = x
	return p
}

func (x ExpOp) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExpOp) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[2].Descriptor()
}

func (ExpOp) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[2]
}

func (x ExpOp) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExpOp.Descriptor instead.
func (ExpOp) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{2}
}

// Read policy for AP (availability) namespaces.
// How duplicates should be consulted in a read operation.
// Only makes a difference during migrations and only applicable in AP mode.
type ReadModeAP int32

const (
	// Involve single node in the read operation.
	ReadModeAP_ReadModeAPOne ReadModeAP = 0
	// Involve all duplicates in the read operation.
	ReadModeAP_ReadModeAPAll ReadModeAP = 1
)

// Enum value maps for ReadModeAP.
var (
	ReadModeAP_name = map[int32]string{
		0: "ReadModeAPOne",
		1: "ReadModeAPAll",
	}
	ReadModeAP_value = map[string]int32{
		"ReadModeAPOne": 0,
		"ReadModeAPAll": 1,
	}
)

func (x ReadModeAP) Enum() *ReadModeAP {
	p := new(ReadModeAP)
	*p = x
	return p
}

func (x ReadModeAP) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReadModeAP) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[3].Descriptor()
}

func (ReadModeAP) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[3]
}

func (x ReadModeAP) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReadModeAP.Descriptor instead.
func (ReadModeAP) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{3}
}

// Read policy for SC (strong consistency) namespaces.
// Determines SC read consistency options.
type ReadModeSC int32

const (
	// Ensures this client will only see an increasing sequence of record versions.
	// Server only reads from master.  This is the default.
	ReadModeSC_ReadModeSCSession ReadModeSC = 0
	// Ensures ALL clients will only see an increasing sequence of record versions.
	// Server only reads from master.
	ReadModeSC_ReadModeSCLinearize ReadModeSC = 1
	// Server may read from master or any full (non-migrating) replica.
	// Increasing sequence of record versions is not guaranteed.
	ReadModeSC_ReadModeSCAllowReplica ReadModeSC = 2
	// Server may read from master or any full (non-migrating) replica or from unavailable
	// partitions.  Increasing sequence of record versions is not guaranteed.
	ReadModeSC_ReadModeSCAllowUnavailable ReadModeSC = 3
)

// Enum value maps for ReadModeSC.
var (
	ReadModeSC_name = map[int32]string{
		0: "ReadModeSCSession",
		1: "ReadModeSCLinearize",
		2: "ReadModeSCAllowReplica",
		3: "ReadModeSCAllowUnavailable",
	}
	ReadModeSC_value = map[string]int32{
		"ReadModeSCSession":          0,
		"ReadModeSCLinearize":        1,
		"ReadModeSCAllowReplica":     2,
		"ReadModeSCAllowUnavailable": 3,
	}
)

func (x ReadModeSC) Enum() *ReadModeSC {
	p := new(ReadModeSC)
	*p = x
	return p
}

func (x ReadModeSC) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReadModeSC) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[4].Descriptor()
}

func (ReadModeSC) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[4]
}

func (x ReadModeSC) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReadModeSC.Descriptor instead.
func (ReadModeSC) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{4}
}

// Defines algorithm used to determine the target node for a command.
// Scan and query are not affected by replica algorithm.
//
// Note: The enum ordinals do not match the Aerospike Client ordinals because
// the default has to be ordinal zero in protobuf.
type ReplicaPolicy int32

const (
	// Try node containing master partition first.
	// If connection fails, all commands try nodes containing replicated partitions.
	// If socketTimeout is reached, reads also try nodes containing replicated partitions,
	// but writes remain on master node.
	ReplicaPolicy_SEQUENCE ReplicaPolicy = 0
	// Use node containing key's master partition.
	ReplicaPolicy_MASTER ReplicaPolicy = 1
	// Distribute reads across nodes containing key's master and replicated partitions
	// in round-robin fashion.  Writes always use node containing key's master partition.
	ReplicaPolicy_MASTER_PROLES ReplicaPolicy = 2
	// Try node on the same rack as the client first.  If timeout or there are no nodes on the
	// same rack, use SEQUENCE instead.
	ReplicaPolicy_PREFER_RACK ReplicaPolicy = 3
	// Distribute reads across all nodes in cluster in round-robin fashion.
	// Writes always use node containing key's master partition.
	// This option is useful when the replication factor equals the number
	// of nodes in the cluster and the overhead of requesting proles is not desired.
	ReplicaPolicy_RANDOM ReplicaPolicy = 4
)

// Enum value maps for ReplicaPolicy.
var (
	ReplicaPolicy_name = map[int32]string{
		0: "SEQUENCE",
		1: "MASTER",
		2: "MASTER_PROLES",
		3: "PREFER_RACK",
		4: "RANDOM",
	}
	ReplicaPolicy_value = map[string]int32{
		"SEQUENCE":      0,
		"MASTER":        1,
		"MASTER_PROLES": 2,
		"PREFER_RACK":   3,
		"RANDOM":        4,
	}
)

func (x ReplicaPolicy) Enum() *ReplicaPolicy {
	p := new(ReplicaPolicy)
	*p = x
	return p
}

func (x ReplicaPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReplicaPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[5].Descriptor()
}

func (ReplicaPolicy) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[5]
}

func (x ReplicaPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReplicaPolicy.Descriptor instead.
func (ReplicaPolicy) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{5}
}

type ConsistencyLevel int32

const (
	ConsistencyLevel_ConsistencyOne ConsistencyLevel = 0
	ConsistencyLevel_ConsistencyAll ConsistencyLevel = 1
)

// Enum value maps for ConsistencyLevel.
var (
	ConsistencyLevel_name = map[int32]string{
		0: "ConsistencyOne",
		1: "ConsistencyAll",
	}
	ConsistencyLevel_value = map[string]int32{
		"ConsistencyOne": 0,
		"ConsistencyAll": 1,
	}
)

func (x ConsistencyLevel) Enum() *ConsistencyLevel {
	p := new(ConsistencyLevel)
	*p = x
	return p
}

func (x ConsistencyLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ConsistencyLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[6].Descriptor()
}

func (ConsistencyLevel) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[6]
}

func (x ConsistencyLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ConsistencyLevel.Descriptor instead.
func (ConsistencyLevel) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{6}
}

// IndexType the type of the secondary index.
type IndexType int32

const (
	// Index on numeric values.
	IndexType_IndexTypeNumeric IndexType = 0
	// Index on string values.
	IndexType_IndexTypeString IndexType = 1
	// Index on []byte values. Requires server version 7.0+.
	IndexType_IndexTypeBlob IndexType = 2
	// 2-dimensional spherical geospatial index.
	IndexType_IndexTypeGeo2DSphere IndexType = 3
)

// Enum value maps for IndexType.
var (
	IndexType_name = map[int32]string{
		0: "IndexTypeNumeric",
		1: "IndexTypeString",
		2: "IndexTypeBlob",
		3: "IndexTypeGeo2DSphere",
	}
	IndexType_value = map[string]int32{
		"IndexTypeNumeric":     0,
		"IndexTypeString":      1,
		"IndexTypeBlob":        2,
		"IndexTypeGeo2DSphere": 3,
	}
)

func (x IndexType) Enum() *IndexType {
	p := new(IndexType)
	*p = x
	return p
}

func (x IndexType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IndexType) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[7].Descriptor()
}

func (IndexType) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[7]
}

func (x IndexType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IndexType.Descriptor instead.
func (IndexType) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{7}
}

// IndexCollectionType is the secondary index collection type.
type IndexCollectionType int32

const (
	// Normal scalar index.
	IndexCollectionType_IndexCollectionTypeDefault IndexCollectionType = 0
	// Index list elements.
	IndexCollectionType_IndexCollectionTypeList IndexCollectionType = 1
	// Index map keys.
	IndexCollectionType_IndexCollectionTypeMapKeys IndexCollectionType = 2
	// Index map values.
	IndexCollectionType_IndexCollectionTypeMapValues IndexCollectionType = 3
)

// Enum value maps for IndexCollectionType.
var (
	IndexCollectionType_name = map[int32]string{
		0: "IndexCollectionTypeDefault",
		1: "IndexCollectionTypeList",
		2: "IndexCollectionTypeMapKeys",
		3: "IndexCollectionTypeMapValues",
	}
	IndexCollectionType_value = map[string]int32{
		"IndexCollectionTypeDefault":   0,
		"IndexCollectionTypeList":      1,
		"IndexCollectionTypeMapKeys":   2,
		"IndexCollectionTypeMapValues": 3,
	}
)

func (x IndexCollectionType) Enum() *IndexCollectionType {
	p := new(IndexCollectionType)
	*p = x
	return p
}

func (x IndexCollectionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IndexCollectionType) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[8].Descriptor()
}

func (IndexCollectionType) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[8]
}

func (x IndexCollectionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IndexCollectionType.Descriptor instead.
func (IndexCollectionType) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{8}
}

// AuthMode determines authentication mode.
type AuthMode int32

const (
	// AuthModeInternal uses internal authentication only when user/password defined. Hashed password is stored
	// on the server. Do not send clear password. This is the default.
	AuthMode_AuthModeInternal AuthMode = 0
	// AuthModeExternal uses external authentication (like LDAP) when user/password defined. Specific external authentication is
	// configured on server.  If TLSConfig is defined, sends clear password on node login via TLS.
	// Will return an error if TLSConfig is not defined.
	AuthMode_AuthModeExternal AuthMode = 1
	// AuthModePKI allows authentication and authorization based on a certificate. No user name or
	// password needs to be configured. Requires TLS and a client certificate.
	// Requires server version 5.7.0+
	AuthMode_AuthModePKI AuthMode = 2
)

// Enum value maps for AuthMode.
var (
	AuthMode_name = map[int32]string{
		0: "AuthModeInternal",
		1: "AuthModeExternal",
		2: "AuthModePKI",
	}
	AuthMode_value = map[string]int32{
		"AuthModeInternal": 0,
		"AuthModeExternal": 1,
		"AuthModePKI":      2,
	}
)

func (x AuthMode) Enum() *AuthMode {
	p := new(AuthMode)
	*p = x
	return p
}

func (x AuthMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AuthMode) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[9].Descriptor()
}

func (AuthMode) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[9]
}

func (x AuthMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AuthMode.Descriptor instead.
func (AuthMode) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{9}
}

// ListOrderType determines the order of returned values in CDT list operations.
type ListOrderType int32

const (
	// Unordered signifies that list is not ordered. This is the default.
	ListOrderType_ListOrderTypeUnordered ListOrderType = 0
	// Ordered signifies that list is Ordered.
	ListOrderType_ListOrderTypeOrdered ListOrderType = 1
)

// Enum value maps for ListOrderType.
var (
	ListOrderType_name = map[int32]string{
		0: "ListOrderTypeUnordered",
		1: "ListOrderTypeOrdered",
	}
	ListOrderType_value = map[string]int32{
		"ListOrderTypeUnordered": 0,
		"ListOrderTypeOrdered":   1,
	}
)

func (x ListOrderType) Enum() *ListOrderType {
	p := new(ListOrderType)
	*p = x
	return p
}

func (x ListOrderType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ListOrderType) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[10].Descriptor()
}

func (ListOrderType) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[10]
}

func (x ListOrderType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ListOrderType.Descriptor instead.
func (ListOrderType) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{10}
}

// MapOrder defines map storage order.
type MapOrderType int32

const (
	// Map is not ordered. This is the default.
	MapOrderType_MapOrderTypeUnordered MapOrderType = 0
	// Order map by key.
	MapOrderType_MapOrderTypeKeyOrdered MapOrderType = 1
	// Order map by key, then value.
	MapOrderType_MapOrderTypeKeyValueOrdered MapOrderType = 3
)

// Enum value maps for MapOrderType.
var (
	MapOrderType_name = map[int32]string{
		0: "MapOrderTypeUnordered",
		1: "MapOrderTypeKeyOrdered",
		3: "MapOrderTypeKeyValueOrdered",
	}
	MapOrderType_value = map[string]int32{
		"MapOrderTypeUnordered":       0,
		"MapOrderTypeKeyOrdered":      1,
		"MapOrderTypeKeyValueOrdered": 3,
	}
)

func (x MapOrderType) Enum() *MapOrderType {
	p := new(MapOrderType)
	*p = x
	return p
}

func (x MapOrderType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MapOrderType) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[11].Descriptor()
}

func (MapOrderType) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[11]
}

func (x MapOrderType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MapOrderType.Descriptor instead.
func (MapOrderType) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{11}
}

type OperationType int32

const (
	OperationType_OperationTypeRead       OperationType = 0
	OperationType_OperationTypeReadHeader OperationType = 1
	OperationType_OperationTypeWrite      OperationType = 2
	OperationType_OperationTypeCdtRead    OperationType = 3
	OperationType_OperationTypeCdtModify  OperationType = 4
	OperationType_OperationTypeMapRead    OperationType = 5
	OperationType_OperationTypeMapModify  OperationType = 6
	OperationType_OperationTypeAdd        OperationType = 7
	OperationType_OperationTypeExpRead    OperationType = 8
	OperationType_OperationTypeExpModify  OperationType = 9
	OperationType_OperationTypeAppend     OperationType = 10
	OperationType_OperationTypePrepend    OperationType = 11
	OperationType_OperationTypeTouch      OperationType = 12
	OperationType_OperationTypeBitRead    OperationType = 13
	OperationType_OperationTypeBitModify  OperationType = 14
	OperationType_OperationTypeDelete     OperationType = 15
	OperationType_OperationTypeHllRead    OperationType = 16
	OperationType_OperationTypeHllModify  OperationType = 17
)

// Enum value maps for OperationType.
var (
	OperationType_name = map[int32]string{
		0:  "OperationTypeRead",
		1:  "OperationTypeReadHeader",
		2:  "OperationTypeWrite",
		3:  "OperationTypeCdtRead",
		4:  "OperationTypeCdtModify",
		5:  "OperationTypeMapRead",
		6:  "OperationTypeMapModify",
		7:  "OperationTypeAdd",
		8:  "OperationTypeExpRead",
		9:  "OperationTypeExpModify",
		10: "OperationTypeAppend",
		11: "OperationTypePrepend",
		12: "OperationTypeTouch",
		13: "OperationTypeBitRead",
		14: "OperationTypeBitModify",
		15: "OperationTypeDelete",
		16: "OperationTypeHllRead",
		17: "OperationTypeHllModify",
	}
	OperationType_value = map[string]int32{
		"OperationTypeRead":       0,
		"OperationTypeReadHeader": 1,
		"OperationTypeWrite":      2,
		"OperationTypeCdtRead":    3,
		"OperationTypeCdtModify":  4,
		"OperationTypeMapRead":    5,
		"OperationTypeMapModify":  6,
		"OperationTypeAdd":        7,
		"OperationTypeExpRead":    8,
		"OperationTypeExpModify":  9,
		"OperationTypeAppend":     10,
		"OperationTypePrepend":    11,
		"OperationTypeTouch":      12,
		"OperationTypeBitRead":    13,
		"OperationTypeBitModify":  14,
		"OperationTypeDelete":     15,
		"OperationTypeHllRead":    16,
		"OperationTypeHllModify":  17,
	}
)

func (x OperationType) Enum() *OperationType {
	p := new(OperationType)
	*p = x
	return p
}

func (x OperationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperationType) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[12].Descriptor()
}

func (OperationType) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[12]
}

func (x OperationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OperationType.Descriptor instead.
func (OperationType) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{12}
}

type RecordExistsAction int32

const (
	// Create or update record.
	// Merge write command bins with existing bins.
	RecordExistsAction_UPDATE RecordExistsAction = 0
	// Update record only. Fail if record does not exist.
	// Merge write command bins with existing bins.
	RecordExistsAction_UPDATE_ONLY RecordExistsAction = 1
	// Create or replace record.
	// Delete existing bins not referenced by write command bins.
	// Supported by Aerospike server versions &gt;= 3.1.6.
	RecordExistsAction_REPLACE RecordExistsAction = 2
	// Replace record only. Fail if record does not exist.
	// Delete existing bins not referenced by write command bins.
	// Supported by Aerospike server versions &gt;= 3.1.6.
	RecordExistsAction_REPLACE_ONLY RecordExistsAction = 3
	// Create only.  Fail if record exists.
	RecordExistsAction_CREATE_ONLY RecordExistsAction = 4
)

// Enum value maps for RecordExistsAction.
var (
	RecordExistsAction_name = map[int32]string{
		0: "UPDATE",
		1: "UPDATE_ONLY",
		2: "REPLACE",
		3: "REPLACE_ONLY",
		4: "CREATE_ONLY",
	}
	RecordExistsAction_value = map[string]int32{
		"UPDATE":       0,
		"UPDATE_ONLY":  1,
		"REPLACE":      2,
		"REPLACE_ONLY": 3,
		"CREATE_ONLY":  4,
	}
)

func (x RecordExistsAction) Enum() *RecordExistsAction {
	p := new(RecordExistsAction)
	*p = x
	return p
}

func (x RecordExistsAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RecordExistsAction) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[13].Descriptor()
}

func (RecordExistsAction) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[13]
}

func (x RecordExistsAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RecordExistsAction.Descriptor instead.
func (RecordExistsAction) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{13}
}

type GenerationPolicy int32

const (
	// Do not use record generation to restrict writes.
	GenerationPolicy_NONE GenerationPolicy = 0
	// Update/delete record if expected generation is equal to server generation. Otherwise, fail.
	GenerationPolicy_EXPECT_GEN_EQUAL GenerationPolicy = 1
	// Update/delete record if expected generation greater than the server generation. Otherwise, fail.
	// This is useful for restore after backup.
	GenerationPolicy_EXPECT_GEN_GT GenerationPolicy = 2
)

// Enum value maps for GenerationPolicy.
var (
	GenerationPolicy_name = map[int32]string{
		0: "NONE",
		1: "EXPECT_GEN_EQUAL",
		2: "EXPECT_GEN_GT",
	}
	GenerationPolicy_value = map[string]int32{
		"NONE":             0,
		"EXPECT_GEN_EQUAL": 1,
		"EXPECT_GEN_GT":    2,
	}
)

func (x GenerationPolicy) Enum() *GenerationPolicy {
	p := new(GenerationPolicy)
	*p = x
	return p
}

func (x GenerationPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (GenerationPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[14].Descriptor()
}

func (GenerationPolicy) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[14]
}

func (x GenerationPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use GenerationPolicy.Descriptor instead.
func (GenerationPolicy) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{14}
}

type CommitLevel int32

const (
	// Server should wait until successfully committing master and all replicas.
	CommitLevel_COMMIT_ALL CommitLevel = 0
	// Server should wait until successfully committing master only.
	CommitLevel_COMMIT_MASTER CommitLevel = 1
)

// Enum value maps for CommitLevel.
var (
	CommitLevel_name = map[int32]string{
		0: "COMMIT_ALL",
		1: "COMMIT_MASTER",
	}
	CommitLevel_value = map[string]int32{
		"COMMIT_ALL":    0,
		"COMMIT_MASTER": 1,
	}
)

func (x CommitLevel) Enum() *CommitLevel {
	p := new(CommitLevel)
	*p = x
	return p
}

func (x CommitLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_asld_kvs_proto_enumTypes[15].Descriptor()
}

func (CommitLevel) Type() protoreflect.EnumType {
	return &file_asld_kvs_proto_enumTypes[15]
}

func (x CommitLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitLevel.Descriptor instead.
func (CommitLevel) EnumDescriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{15}
}

// Expression which can be applied to most commands, to control which records are
// affected by the command.
type Expression struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The Operation code
	Cmd *ExpOp `protobuf:"varint,1,opt,name=cmd,proto3,enum=com.aerospike.daemon.ExpOp,oneof" json:"cmd,omitempty"`
	// The Primary Value of the Operation
	Val *Value `protobuf:"bytes,2,opt,name=val,proto3,oneof" json:"val,omitempty"`
	// The Bin to use it on (REGEX for example)
	Bin *Expression `protobuf:"bytes,3,opt,name=bin,proto3,oneof" json:"bin,omitempty"`
	// The additional flags for the Operation (REGEX or return_type of Module for example)
	Flags *int64 `protobuf:"varint,4,opt,name=flags,proto3,oneof" json:"flags,omitempty"`
	// The optional Module flag for Module operations or Bin Types
	Module *ExpType `protobuf:"varint,5,opt,name=module,proto3,enum=com.aerospike.daemon.ExpType,oneof" json:"module,omitempty"`
	// Sub commands for the CmdExp operation
	Exps []*Expression `protobuf:"bytes,6,rep,name=exps,proto3" json:"exps,omitempty"`
}

func (x *Expression) Reset() {
	*x = Expression{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Expression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Expression) ProtoMessage() {}

func (x *Expression) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Expression.ProtoReflect.Descriptor instead.
func (*Expression) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{0}
}

func (x *Expression) GetCmd() ExpOp {
	if x != nil && x.Cmd != nil {
		return *x.Cmd
	}
	return ExpOp_ExpOpUnknown
}

func (x *Expression) GetVal() *Value {
	if x != nil {
		return x.Val
	}
	return nil
}

func (x *Expression) GetBin() *Expression {
	if x != nil {
		return x.Bin
	}
	return nil
}

func (x *Expression) GetFlags() int64 {
	if x != nil && x.Flags != nil {
		return *x.Flags
	}
	return 0
}

func (x *Expression) GetModule() ExpType {
	if x != nil && x.Module != nil {
		return *x.Module
	}
	return ExpType_ExpTypeNil
}

func (x *Expression) GetExps() []*Expression {
	if x != nil {
		return x.Exps
	}
	return nil
}

// ReadPolicy encapsulates parameters for transaction policy attributes
// used in all database operation calls.
type ReadPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// FilterExpression is the optional Filter Expression. Supported on Server v5.2+
	FilterExpression *Expression `protobuf:"bytes,1,opt,name=filterExpression,proto3,oneof" json:"filterExpression,omitempty"`
	// ReadModeAP indicates read policy for AP (availability) namespaces.
	ReadModeAP ReadModeAP `protobuf:"varint,2,opt,name=readModeAP,proto3,enum=com.aerospike.daemon.ReadModeAP" json:"readModeAP,omitempty"`
	// ReadModeSC indicates read policy for SC (strong consistency) namespaces.
	ReadModeSC ReadModeSC `protobuf:"varint,3,opt,name=readModeSC,proto3,enum=com.aerospike.daemon.ReadModeSC" json:"readModeSC,omitempty"`
	// TotalTimeout specifies total transaction timeout.
	//
	// The TotalTimeout is tracked on the client and also sent to the server along
	// with the transaction in the wire protocol. The client will most likely
	// timeout first, but the server has the capability to Timeout the transaction.
	//
	// If TotalTimeout is not zero and TotalTimeout is reached before the transaction
	// completes, the transaction will abort with TotalTimeout error.
	//
	// If TotalTimeout is zero, there will be no time limit and the transaction will retry
	// on network timeouts/errors until MaxRetries is exceeded. If MaxRetries is exceeded, the
	// transaction also aborts with Timeout error.
	TotalTimeout uint64 `protobuf:"varint,4,opt,name=totalTimeout,proto3" json:"totalTimeout,omitempty"`
	// SocketTimeout determines network timeout for each attempt.
	//
	// If SocketTimeout is not zero and SocketTimeout is reached before an attempt completes,
	// the Timeout above is checked. If Timeout is not exceeded, the transaction
	// is retried. If both SocketTimeout and Timeout are non-zero, SocketTimeout must be less
	// than or equal to Timeout, otherwise Timeout will also be used for SocketTimeout.
	SocketTimeout uint64 `protobuf:"varint,5,opt,name=socketTimeout,proto3" json:"socketTimeout,omitempty"`
	// MaxRetries determines the maximum number of retries before aborting the current transaction.
	// The initial attempt is not counted as a retry.
	//
	// If MaxRetries is exceeded, the transaction will abort with an error.
	//
	// WARNING: Database writes that are not idempotent (such as AddOp)
	// should not be retried because the write operation may be performed
	// multiple times if the client timed out previous transaction attempts.
	// It's important to use a distinct WritePolicy for non-idempotent
	// writes which sets maxRetries = 0;
	MaxRetries uint32 `protobuf:"varint,6,opt,name=maxRetries,proto3" json:"maxRetries,omitempty"`
	// SleepBetweenRtries determines the duration to sleep between retries.  Enter zero to skip sleep.
	// This field is ignored when maxRetries is zero.
	// This field is also ignored in async mode.
	//
	// The sleep only occurs on connection errors and server timeouts
	// which suggest a node is down and the cluster is reforming.
	// The sleep does not occur when the client's socketTimeout expires.
	//
	// Reads do not have to sleep when a node goes down because the cluster
	// does not shut out reads during cluster reformation.  The default for
	// reads is zero.
	//
	// The default for writes is also zero because writes are not retried by default.
	// Writes need to wait for the cluster to reform when a node goes down.
	// Immediate write retries on node failure have been shown to consistently
	// result in errors.  If maxRetries is greater than zero on a write, then
	// sleepBetweenRetries should be set high enough to allow the cluster to
	// reform (>= 500ms).
	SleepBetweenRetries int64 `protobuf:"varint,7,opt,name=sleepBetweenRetries,proto3" json:"sleepBetweenRetries,omitempty"`
	// SleepMultiplier specifies the multiplying factor to be used for exponential backoff during retries.
	// Default to (1.0); Only values greater than 1 are valid.
	SleepMultiplier float64 `protobuf:"fixed64,8,opt,name=sleepMultiplier,proto3" json:"sleepMultiplier,omitempty"`
	// ExitFastOnExhaustedConnectionPool determines if a command that tries to get a
	// connection from the connection pool will wait and retry in case the pool is
	// exhausted until a connection becomes available (or the TotalTimeout is reached).
	// If set to true, an error will be return immediately.
	// If set to false, getting a connection will be retried.
	// This only applies if LimitConnectionsToQueueSize is set to true and the number of open connections to a node has reached ConnectionQueueSize.
	ExitFastOnExhaustedConnectionPool bool `protobuf:"varint,9,opt,name=exitFastOnExhaustedConnectionPool,proto3" json:"exitFastOnExhaustedConnectionPool,omitempty"`
	// SendKey determines to whether send user defined key in addition to hash digest on both reads and writes.
	// If the key is sent on a write, the key will be stored with the record on
	// the server.
	SendKey bool `protobuf:"varint,10,opt,name=sendKey,proto3" json:"sendKey,omitempty"`
	// UseCompression uses zlib compression on command buffers sent to the server and responses received
	// from the server when the buffer size is greater than 128 bytes.
	//
	// This option will increase cpu and memory usage (for extra compressed buffers),but
	// decrease the size of data sent over the network.
	UseCompression bool `protobuf:"varint,11,opt,name=useCompression,proto3" json:"useCompression,omitempty"`
	// ReplicaPolicy specifies the algorithm used to determine the target node for a partition derived from a key
	// or requested in a scan/query.
	// Write commands are not affected by this setting, because all writes are directed
	// to the node containing the key's master partition.
	ReplicaPolicy ReplicaPolicy `protobuf:"varint,12,opt,name=replicaPolicy,proto3,enum=com.aerospike.daemon.ReplicaPolicy" json:"replicaPolicy,omitempty"`
}

func (x *ReadPolicy) Reset() {
	*x = ReadPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReadPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReadPolicy) ProtoMessage() {}

func (x *ReadPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReadPolicy.ProtoReflect.Descriptor instead.
func (*ReadPolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{1}
}

func (x *ReadPolicy) GetFilterExpression() *Expression {
	if x != nil {
		return x.FilterExpression
	}
	return nil
}

func (x *ReadPolicy) GetReadModeAP() ReadModeAP {
	if x != nil {
		return x.ReadModeAP
	}
	return ReadModeAP_ReadModeAPOne
}

func (x *ReadPolicy) GetReadModeSC() ReadModeSC {
	if x != nil {
		return x.ReadModeSC
	}
	return ReadModeSC_ReadModeSCSession
}

func (x *ReadPolicy) GetTotalTimeout() uint64 {
	if x != nil {
		return x.TotalTimeout
	}
	return 0
}

func (x *ReadPolicy) GetSocketTimeout() uint64 {
	if x != nil {
		return x.SocketTimeout
	}
	return 0
}

func (x *ReadPolicy) GetMaxRetries() uint32 {
	if x != nil {
		return x.MaxRetries
	}
	return 0
}

func (x *ReadPolicy) GetSleepBetweenRetries() int64 {
	if x != nil {
		return x.SleepBetweenRetries
	}
	return 0
}

func (x *ReadPolicy) GetSleepMultiplier() float64 {
	if x != nil {
		return x.SleepMultiplier
	}
	return 0
}

func (x *ReadPolicy) GetExitFastOnExhaustedConnectionPool() bool {
	if x != nil {
		return x.ExitFastOnExhaustedConnectionPool
	}
	return false
}

func (x *ReadPolicy) GetSendKey() bool {
	if x != nil {
		return x.SendKey
	}
	return false
}

func (x *ReadPolicy) GetUseCompression() bool {
	if x != nil {
		return x.UseCompression
	}
	return false
}

func (x *ReadPolicy) GetReplicaPolicy() ReplicaPolicy {
	if x != nil {
		return x.ReplicaPolicy
	}
	return ReplicaPolicy_SEQUENCE
}

// Write policy attributes used in write database commands that are not part of
// the wire protocol.
type WritePolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy *ReadPolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	// RecordExistsAction qualifies how to handle writes where the record already exists.
	RecordExistsAction RecordExistsAction `protobuf:"varint,2,opt,name=recordExistsAction,proto3,enum=com.aerospike.daemon.RecordExistsAction" json:"recordExistsAction,omitempty"`
	// GenerationPolicy qualifies how to handle record writes based on record generation. The default (NONE)
	// indicates that the generation is not used to restrict writes.
	GenerationPolicy GenerationPolicy `protobuf:"varint,3,opt,name=generationPolicy,proto3,enum=com.aerospike.daemon.GenerationPolicy" json:"generationPolicy,omitempty"`
	// Desired consistency guarantee when committing a transaction on the server. The default
	// (COMMIT_ALL) indicates that the server should wait for master and all replica commits to
	// be successful before returning success to the client.
	CommitLevel CommitLevel `protobuf:"varint,4,opt,name=commitLevel,proto3,enum=com.aerospike.daemon.CommitLevel" json:"commitLevel,omitempty"`
	// Generation determines expected generation.
	// Generation is the number of times a record has been
	// modified (including creation) on the server.
	// If a write operation is creating a record, the expected generation would be 0.
	Generation uint32 `protobuf:"varint,5,opt,name=generation,proto3" json:"generation,omitempty"`
	// Expiration determines record expiration in seconds. Also known as TTL (Time-To-Live).
	// Seconds record will live before being removed by the server.
	// Expiration values:
	// TTLServerDefault (0): Default to namespace configuration variable "default-ttl" on the server.
	// TTLDontExpire (MaxUint32): Never expire for Aerospike 2 server versions >= 2.7.2 and Aerospike 3+ server
	// TTLDontUpdate (MaxUint32 - 1): Do not change ttl when record is written. Supported by Aerospike server versions >= 3.10.1
	// > 0: Actual expiration in seconds.
	Expiration uint32 `protobuf:"varint,6,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// RespondPerEachOp defines for client.Operate() method, return a result for every operation.
	// Some list operations do not return results by default (ListClearOp() for example).
	// This can sometimes make it difficult to determine the desired result offset in the returned
	// bin's result list.
	//
	// Setting RespondPerEachOp to true makes it easier to identify the desired result offset
	// (result offset equals bin's operate sequence). This only makes sense when multiple list
	// operations are used in one operate call and some of those operations do not return results
	// by default.
	RespondPerEachOp bool `protobuf:"varint,7,opt,name=respondPerEachOp,proto3" json:"respondPerEachOp,omitempty"`
	// DurableDelete leaves a tombstone for the record if the transaction results in a record deletion.
	// This prevents deleted records from reappearing after node failures.
	// Valid for Aerospike Server Enterprise Edition 3.10+ only.
	DurableDelete bool `protobuf:"varint,8,opt,name=durableDelete,proto3" json:"durableDelete,omitempty"`
}

func (x *WritePolicy) Reset() {
	*x = WritePolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WritePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WritePolicy) ProtoMessage() {}

func (x *WritePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WritePolicy.ProtoReflect.Descriptor instead.
func (*WritePolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{2}
}

func (x *WritePolicy) GetPolicy() *ReadPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *WritePolicy) GetRecordExistsAction() RecordExistsAction {
	if x != nil {
		return x.RecordExistsAction
	}
	return RecordExistsAction_UPDATE
}

func (x *WritePolicy) GetGenerationPolicy() GenerationPolicy {
	if x != nil {
		return x.GenerationPolicy
	}
	return GenerationPolicy_NONE
}

func (x *WritePolicy) GetCommitLevel() CommitLevel {
	if x != nil {
		return x.CommitLevel
	}
	return CommitLevel_COMMIT_ALL
}

func (x *WritePolicy) GetGeneration() uint32 {
	if x != nil {
		return x.Generation
	}
	return 0
}

func (x *WritePolicy) GetExpiration() uint32 {
	if x != nil {
		return x.Expiration
	}
	return 0
}

func (x *WritePolicy) GetRespondPerEachOp() bool {
	if x != nil {
		return x.RespondPerEachOp
	}
	return false
}

func (x *WritePolicy) GetDurableDelete() bool {
	if x != nil {
		return x.DurableDelete
	}
	return false
}

// InfoPolicy contains attributes used for info commands.
type InfoPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Info command socket timeout.
	Timeout uint32 `protobuf:"varint,1,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (x *InfoPolicy) Reset() {
	*x = InfoPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InfoPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InfoPolicy) ProtoMessage() {}

func (x *InfoPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InfoPolicy.ProtoReflect.Descriptor instead.
func (*InfoPolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{3}
}

func (x *InfoPolicy) GetTimeout() uint32 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

// BatchReadPolicy attributes used in batch read commands.
type BatchReadPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// FilterExpression is the optional expression filter. If FilterExpression exists and evaluates to false, the specific batch key
	// request is not performed and BatchRecord.ResultCode is set to types.FILTERED_OUT.
	FilterExpression *Expression `protobuf:"bytes,1,opt,name=filter_expression,json=filterExpression,proto3,oneof" json:"filter_expression,omitempty"`
	// ReadModeAP indicates read policy for AP (availability) namespaces.
	ReadModeAP ReadModeAP `protobuf:"varint,2,opt,name=readModeAP,proto3,enum=com.aerospike.daemon.ReadModeAP" json:"readModeAP,omitempty"`
	// ReadModeSC indicates read policy for SC (strong consistency) namespaces.
	ReadModeSC ReadModeSC `protobuf:"varint,3,opt,name=readModeSC,proto3,enum=com.aerospike.daemon.ReadModeSC" json:"readModeSC,omitempty"`
}

func (x *BatchReadPolicy) Reset() {
	*x = BatchReadPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchReadPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchReadPolicy) ProtoMessage() {}

func (x *BatchReadPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchReadPolicy.ProtoReflect.Descriptor instead.
func (*BatchReadPolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{4}
}

func (x *BatchReadPolicy) GetFilterExpression() *Expression {
	if x != nil {
		return x.FilterExpression
	}
	return nil
}

func (x *BatchReadPolicy) GetReadModeAP() ReadModeAP {
	if x != nil {
		return x.ReadModeAP
	}
	return ReadModeAP_ReadModeAPOne
}

func (x *BatchReadPolicy) GetReadModeSC() ReadModeSC {
	if x != nil {
		return x.ReadModeSC
	}
	return ReadModeSC_ReadModeSCSession
}

// BatchWritePolicy attributes used in batch write commands.
type BatchWritePolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// FilterExpression is optional expression filter. If FilterExpression exists and evaluates to false, the specific batch key
	// request is not performed and BatchRecord#resultCode is set to types.FILTERED_OUT.
	FilterExpression *Expression `protobuf:"bytes,1,opt,name=filter_expression,json=filterExpression,proto3,oneof" json:"filter_expression,omitempty"`
	// RecordExistsAction qualifies how to handle writes where the record already exists.
	RecordExistsAction RecordExistsAction `protobuf:"varint,2,opt,name=RecordExistsAction,proto3,enum=com.aerospike.daemon.RecordExistsAction" json:"RecordExistsAction,omitempty"`
	// Desired consistency guarantee when committing a transaction on the server. The default
	// (COMMIT_ALL) indicates that the server should wait for master and all replica commits to
	// be successful before returning success to the client.
	//
	// Default: CommitLevel.COMMIT_ALL
	CommitLevel CommitLevel `protobuf:"varint,3,opt,name=commitLevel,proto3,enum=com.aerospike.daemon.CommitLevel" json:"commitLevel,omitempty"`
	// GenerationPolicy qualifies how to handle record writes based on record generation. The default (NONE)
	// indicates that the generation is not used to restrict writes.
	//
	// The server does not support this field for UDF execute() calls. The read-modify-write
	// usage model can still be enforced inside the UDF code itself.
	//
	// Default: GenerationPolicy.NONE
	// indicates that the generation is not used to restrict writes.
	GenerationPolicy GenerationPolicy `protobuf:"varint,4,opt,name=generationPolicy,proto3,enum=com.aerospike.daemon.GenerationPolicy" json:"generationPolicy,omitempty"`
	// Expected generation. Generation is the number of times a record has been modified
	// (including creation) on the server. If a write operation is creating a record,
	// the expected generation would be 0. This field is only relevant when
	// generationPolicy is not NONE.
	//
	// The server does not support this field for UDF execute() calls. The read-modify-write
	// usage model can still be enforced inside the UDF code itself.
	//
	// Default: 0
	Generation uint32 `protobuf:"varint,5,opt,name=generation,proto3" json:"generation,omitempty"`
	// Expiration determines record expiration in seconds. Also known as TTL (Time-To-Live).
	// Seconds record will live before being removed by the server.
	// Expiration values:
	// TTLServerDefault (0): Default to namespace configuration variable "default-ttl" on the server.
	// TTLDontExpire (MaxUint32): Never expire for Aerospike 2 server versions >= 2.7.2 and Aerospike 3+ server
	// TTLDontUpdate (MaxUint32 - 1): Do not change ttl when record is written. Supported by Aerospike server versions >= 3.10.1
	// > 0: Actual expiration in seconds.
	Expiration uint32 `protobuf:"varint,6,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// DurableDelete leaves a tombstone for the record if the transaction results in a record deletion.
	// This prevents deleted records from reappearing after node failures.
	// Valid for Aerospike Server Enterprise Edition 3.10+ only.
	DurableDelete bool `protobuf:"varint,7,opt,name=durableDelete,proto3" json:"durableDelete,omitempty"`
	// SendKey determines to whether send user defined key in addition to hash digest on both reads and writes.
	// If the key is sent on a write, the key will be stored with the record on
	// the server.
	// The default is to not send the user defined key.
	SendKey bool `protobuf:"varint,8,opt,name=sendKey,proto3" json:"sendKey,omitempty"`
}

func (x *BatchWritePolicy) Reset() {
	*x = BatchWritePolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchWritePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchWritePolicy) ProtoMessage() {}

func (x *BatchWritePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchWritePolicy.ProtoReflect.Descriptor instead.
func (*BatchWritePolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{5}
}

func (x *BatchWritePolicy) GetFilterExpression() *Expression {
	if x != nil {
		return x.FilterExpression
	}
	return nil
}

func (x *BatchWritePolicy) GetRecordExistsAction() RecordExistsAction {
	if x != nil {
		return x.RecordExistsAction
	}
	return RecordExistsAction_UPDATE
}

func (x *BatchWritePolicy) GetCommitLevel() CommitLevel {
	if x != nil {
		return x.CommitLevel
	}
	return CommitLevel_COMMIT_ALL
}

func (x *BatchWritePolicy) GetGenerationPolicy() GenerationPolicy {
	if x != nil {
		return x.GenerationPolicy
	}
	return GenerationPolicy_NONE
}

func (x *BatchWritePolicy) GetGeneration() uint32 {
	if x != nil {
		return x.Generation
	}
	return 0
}

func (x *BatchWritePolicy) GetExpiration() uint32 {
	if x != nil {
		return x.Expiration
	}
	return 0
}

func (x *BatchWritePolicy) GetDurableDelete() bool {
	if x != nil {
		return x.DurableDelete
	}
	return false
}

func (x *BatchWritePolicy) GetSendKey() bool {
	if x != nil {
		return x.SendKey
	}
	return false
}

// BatchDeletePolicy is used in batch delete commands.
type BatchDeletePolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// FilterExpression is optional expression filter. If FilterExpression exists and evaluates to false, the specific batch key
	// request is not performed and BatchRecord.ResultCode is set to type.FILTERED_OUT.
	FilterExpression *Expression `protobuf:"bytes,1,opt,name=filter_expression,json=filterExpression,proto3,oneof" json:"filter_expression,omitempty"`
	// Desired consistency guarantee when committing a transaction on the server. The default
	// (COMMIT_ALL) indicates that the server should wait for master and all replica commits to
	// be successful before returning success to the client.
	// Default: CommitLevel.COMMIT_ALL
	CommitLevel CommitLevel `protobuf:"varint,2,opt,name=commitLevel,proto3,enum=com.aerospike.daemon.CommitLevel" json:"commitLevel,omitempty"`
	// Qualify how to handle record deletes based on record generation. The default (NONE)
	// indicates that the generation is not used to restrict deletes.
	// Default: GenerationPolicy.NONE
	GenerationPolicy GenerationPolicy `protobuf:"varint,3,opt,name=generationPolicy,proto3,enum=com.aerospike.daemon.GenerationPolicy" json:"generationPolicy,omitempty"`
	// Expected generation. Generation is the number of times a record has been modified
	// (including creation) on the server. This field is only relevant when generationPolicy
	// is not NONE.
	// Default: 0
	Generation uint32 `protobuf:"varint,4,opt,name=generation,proto3" json:"generation,omitempty"`
	// If the transaction results in a record deletion, leave a tombstone for the record.
	// This prevents deleted records from reappearing after node failures.
	// Valid for Aerospike Server Enterprise Edition only.
	// Default: false (do not tombstone deleted records).
	DurableDelete bool `protobuf:"varint,5,opt,name=durableDelete,proto3" json:"durableDelete,omitempty"`
	// Send user defined key in addition to hash digest.
	// If true, the key will be stored with the tombstone record on the server.
	// Default: false (do not send the user defined key)
	SendKey bool `protobuf:"varint,6,opt,name=sendKey,proto3" json:"sendKey,omitempty"`
}

func (x *BatchDeletePolicy) Reset() {
	*x = BatchDeletePolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchDeletePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchDeletePolicy) ProtoMessage() {}

func (x *BatchDeletePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchDeletePolicy.ProtoReflect.Descriptor instead.
func (*BatchDeletePolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{6}
}

func (x *BatchDeletePolicy) GetFilterExpression() *Expression {
	if x != nil {
		return x.FilterExpression
	}
	return nil
}

func (x *BatchDeletePolicy) GetCommitLevel() CommitLevel {
	if x != nil {
		return x.CommitLevel
	}
	return CommitLevel_COMMIT_ALL
}

func (x *BatchDeletePolicy) GetGenerationPolicy() GenerationPolicy {
	if x != nil {
		return x.GenerationPolicy
	}
	return GenerationPolicy_NONE
}

func (x *BatchDeletePolicy) GetGeneration() uint32 {
	if x != nil {
		return x.Generation
	}
	return 0
}

func (x *BatchDeletePolicy) GetDurableDelete() bool {
	if x != nil {
		return x.DurableDelete
	}
	return false
}

func (x *BatchDeletePolicy) GetSendKey() bool {
	if x != nil {
		return x.SendKey
	}
	return false
}

// BatchUDFPolicy attributes used in batch UDF execute commands.
type BatchUDFPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional expression filter. If FilterExpression exists and evaluates to false, the specific batch key
	// request is not performed and BatchRecord.ResultCode is set to types.FILTERED_OUT.
	FilterExpression *Expression `protobuf:"bytes,1,opt,name=filter_expression,json=filterExpression,proto3,oneof" json:"filter_expression,omitempty"`
	// Desired consistency guarantee when committing a transaction on the server. The default
	// (COMMIT_ALL) indicates that the server should wait for master and all replica commits to
	// be successful before returning success to the client.
	//
	// Default: CommitLevel.COMMIT_ALL
	CommitLevel CommitLevel `protobuf:"varint,2,opt,name=commitLevel,proto3,enum=com.aerospike.daemon.CommitLevel" json:"commitLevel,omitempty"`
	// Expiration determines record expiration in seconds. Also known as TTL (Time-To-Live).
	// Seconds record will live before being removed by the server.
	// Expiration values:
	// TTLServerDefault (0): Default to namespace configuration variable "default-ttl" on the server.
	// TTLDontExpire (MaxUint32): Never expire for Aerospike 2 server versions >= 2.7.2 and Aerospike 3+ server
	// TTLDontUpdate (MaxUint32 - 1): Do not change ttl when record is written. Supported by Aerospike server versions >= 3.10.1
	// > 0: Actual expiration in seconds.
	Expiration uint32 `protobuf:"varint,3,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// DurableDelete leaves a tombstone for the record if the transaction results in a record deletion.
	// This prevents deleted records from reappearing after node failures.
	// Valid for Aerospike Server Enterprise Edition 3.10+ only.
	DurableDelete bool `protobuf:"varint,4,opt,name=durableDelete,proto3" json:"durableDelete,omitempty"`
	// SendKey determines to whether send user defined key in addition to hash digest on both reads and writes.
	// If the key is sent on a write, the key will be stored with the record on
	// the server.
	// The default is to not send the user defined key.
	SendKey bool `protobuf:"varint,5,opt,name=sendKey,proto3" json:"sendKey,omitempty"`
}

func (x *BatchUDFPolicy) Reset() {
	*x = BatchUDFPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchUDFPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchUDFPolicy) ProtoMessage() {}

func (x *BatchUDFPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchUDFPolicy.ProtoReflect.Descriptor instead.
func (*BatchUDFPolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{7}
}

func (x *BatchUDFPolicy) GetFilterExpression() *Expression {
	if x != nil {
		return x.FilterExpression
	}
	return nil
}

func (x *BatchUDFPolicy) GetCommitLevel() CommitLevel {
	if x != nil {
		return x.CommitLevel
	}
	return CommitLevel_COMMIT_ALL
}

func (x *BatchUDFPolicy) GetExpiration() uint32 {
	if x != nil {
		return x.Expiration
	}
	return 0
}

func (x *BatchUDFPolicy) GetDurableDelete() bool {
	if x != nil {
		return x.DurableDelete
	}
	return false
}

func (x *BatchUDFPolicy) GetSendKey() bool {
	if x != nil {
		return x.SendKey
	}
	return false
}

// BatchPolicy encapsulates parameters for policy attributes used in write operations.
// This object is passed into methods where database writes can occur.
type BatchPolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy *ReadPolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	// Maximum number of concurrent batch request goroutines to server nodes at any point in time.
	// If there are 16 node/namespace combinations requested and ConcurrentNodes is 8,
	// then batch requests will be made for 8 node/namespace combinations in concurrent goroutines.
	// When a request completes, a new request will be issued until all 16 goroutines are complete.
	//
	// Values:
	// 1: Issue batch requests sequentially.  This mode has a performance advantage for small
	// to medium sized batch sizes because requests can be issued in the main transaction goroutine.
	// This is the default.
	// 0: Issue all batch requests in concurrent goroutines.  This mode has a performance
	// advantage for extremely large batch sizes because each node can process the request
	// immediately.  The downside is extra goroutines will need to be created (or taken from
	// a goroutine pool).
	// > 0: Issue up to ConcurrentNodes batch requests in concurrent goroutines.  When a request
	// completes, a new request will be issued until all goroutines are complete.  This mode
	// prevents too many concurrent goroutines being created for large cluster implementations.
	// The downside is extra goroutines will still need to be created (or taken from a goroutine pool).
	ConcurrentNodes *int32 `protobuf:"varint,2,opt,name=concurrentNodes,proto3,oneof" json:"concurrentNodes,omitempty"`
	// Allow batch to be processed immediately in the server's receiving thread when the server
	// deems it to be appropriate.  If false, the batch will always be processed in separate
	// transaction goroutines.  This field is only relevant for the new batch index protocol.
	//
	// For batch exists or batch reads of smaller sized records (<= 1K per record), inline
	// processing will be significantly faster on "in memory" namespaces.  The server disables
	// inline processing on disk based namespaces regardless of this policy field.
	//
	// Inline processing can introduce the possibility of unfairness because the server
	// can process the entire batch before moving onto the next command.
	AllowInline bool `protobuf:"varint,3,opt,name=allowInline,proto3" json:"allowInline,omitempty"`
	// Allow batch to be processed immediately in the server's receiving thread for SSD
	// namespaces. If false, the batch will always be processed in separate service threads.
	// Server versions before 6.0 ignore this field.
	//
	// Inline processing can introduce the possibility of unfairness because the server
	// can process the entire batch before moving onto the next command.
	//
	// Default: false
	AllowInlineSSD bool `protobuf:"varint,4,opt,name=allowInlineSSD,proto3" json:"allowInlineSSD,omitempty"`
	// Should all batch keys be attempted regardless of errors. This field is used on both
	// the client and server. The client handles node specific errors and the server handles
	// key specific errors.
	//
	// If true, every batch key is attempted regardless of previous key specific errors.
	// Node specific errors such as timeouts stop keys to that node, but keys directed at
	// other nodes will continue to be processed.
	//
	// If false, the server will stop the batch to its node on most key specific errors.
	// The exceptions are types.KEY_NOT_FOUND_ERROR and types.FILTERED_OUT which never stop the batch.
	// The client will stop the entire batch on node specific errors for sync commands
	// that are run in sequence (MaxConcurrentThreads == 1). The client will not stop
	// the entire batch for async commands or sync commands run in parallel.
	//
	// Server versions &lt; 6.0 do not support this field and treat this value as false
	// for key specific errors.
	//
	// Default: true
	RespondAllKeys bool `protobuf:"varint,5,opt,name=respondAllKeys,proto3" json:"respondAllKeys,omitempty"`
	// AllowPartialResults determines if the results for some nodes should be returned in case
	// some nodes encounter an error. The result for the unreceived records will be nil.
	// The returned records will be safe to use, since only fully received data will be parsed
	// and set.
	//
	// This flag is only supported for BatchGet and BatchGetHeader methods. BatchGetComplex always returns
	// partial results by design.
	AllowPartialResults bool `protobuf:"varint,6,opt,name=AllowPartialResults,proto3" json:"AllowPartialResults,omitempty"`
}

func (x *BatchPolicy) Reset() {
	*x = BatchPolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchPolicy) ProtoMessage() {}

func (x *BatchPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchPolicy.ProtoReflect.Descriptor instead.
func (*BatchPolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{8}
}

func (x *BatchPolicy) GetPolicy() *ReadPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *BatchPolicy) GetConcurrentNodes() int32 {
	if x != nil && x.ConcurrentNodes != nil {
		return *x.ConcurrentNodes
	}
	return 0
}

func (x *BatchPolicy) GetAllowInline() bool {
	if x != nil {
		return x.AllowInline
	}
	return false
}

func (x *BatchPolicy) GetAllowInlineSSD() bool {
	if x != nil {
		return x.AllowInlineSSD
	}
	return false
}

func (x *BatchPolicy) GetRespondAllKeys() bool {
	if x != nil {
		return x.RespondAllKeys
	}
	return false
}

func (x *BatchPolicy) GetAllowPartialResults() bool {
	if x != nil {
		return x.AllowPartialResults
	}
	return false
}

type Bin struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Bin) Reset() {
	*x = Bin{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Bin) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Bin) ProtoMessage() {}

func (x *Bin) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Bin.ProtoReflect.Descriptor instead.
func (*Bin) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{9}
}

func (x *Bin) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Bin) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

type List struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	L []*Value `protobuf:"bytes,1,rep,name=l,proto3" json:"l,omitempty"`
}

func (x *List) Reset() {
	*x = List{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *List) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*List) ProtoMessage() {}

func (x *List) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use List.ProtoReflect.Descriptor instead.
func (*List) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{10}
}

func (x *List) GetL() []*Value {
	if x != nil {
		return x.L
	}
	return nil
}

type MapEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	K *Value `protobuf:"bytes,1,opt,name=k,proto3" json:"k,omitempty"`
	V *Value `protobuf:"bytes,2,opt,name=v,proto3" json:"v,omitempty"`
}

func (x *MapEntry) Reset() {
	*x = MapEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MapEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapEntry) ProtoMessage() {}

func (x *MapEntry) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapEntry.ProtoReflect.Descriptor instead.
func (*MapEntry) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{11}
}

func (x *MapEntry) GetK() *Value {
	if x != nil {
		return x.K
	}
	return nil
}

func (x *MapEntry) GetV() *Value {
	if x != nil {
		return x.V
	}
	return nil
}

type Map struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	M []*MapEntry `protobuf:"bytes,1,rep,name=m,proto3" json:"m,omitempty"`
}

func (x *Map) Reset() {
	*x = Map{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Map) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Map) ProtoMessage() {}

func (x *Map) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Map.ProtoReflect.Descriptor instead.
func (*Map) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{12}
}

func (x *Map) GetM() []*MapEntry {
	if x != nil {
		return x.M
	}
	return nil
}

type JsonEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	K string `protobuf:"bytes,1,opt,name=k,proto3" json:"k,omitempty"`
	V *Value `protobuf:"bytes,2,opt,name=v,proto3" json:"v,omitempty"`
}

func (x *JsonEntry) Reset() {
	*x = JsonEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *JsonEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JsonEntry) ProtoMessage() {}

func (x *JsonEntry) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JsonEntry.ProtoReflect.Descriptor instead.
func (*JsonEntry) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{13}
}

func (x *JsonEntry) GetK() string {
	if x != nil {
		return x.K
	}
	return ""
}

func (x *JsonEntry) GetV() *Value {
	if x != nil {
		return x.V
	}
	return nil
}

type Json struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	J []*JsonEntry `protobuf:"bytes,1,rep,name=j,proto3" json:"j,omitempty"`
}

func (x *Json) Reset() {
	*x = Json{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Json) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Json) ProtoMessage() {}

func (x *Json) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Json.ProtoReflect.Descriptor instead.
func (*Json) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{14}
}

func (x *Json) GetJ() []*JsonEntry {
	if x != nil {
		return x.J
	}
	return nil
}

type Value struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to V:
	//	*Value_Nil
	//	*Value_I
	//	*Value_F
	//	*Value_S
	//	*Value_B
	//	*Value_Blob
	//	*Value_L
	//	*Value_M
	//	*Value_Json
	//	*Value_Geo
	//	*Value_Hll
	//	*Value_Wildcard
	//	*Value_Infinity
	V isValue_V `protobuf_oneof:"v"`
}

func (x *Value) Reset() {
	*x = Value{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Value) ProtoMessage() {}

func (x *Value) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Value.ProtoReflect.Descriptor instead.
func (*Value) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{15}
}

func (m *Value) GetV() isValue_V {
	if m != nil {
		return m.V
	}
	return nil
}

func (x *Value) GetNil() bool {
	if x, ok := x.GetV().(*Value_Nil); ok {
		return x.Nil
	}
	return false
}

func (x *Value) GetI() int64 {
	if x, ok := x.GetV().(*Value_I); ok {
		return x.I
	}
	return 0
}

func (x *Value) GetF() float64 {
	if x, ok := x.GetV().(*Value_F); ok {
		return x.F
	}
	return 0
}

func (x *Value) GetS() string {
	if x, ok := x.GetV().(*Value_S); ok {
		return x.S
	}
	return ""
}

func (x *Value) GetB() bool {
	if x, ok := x.GetV().(*Value_B); ok {
		return x.B
	}
	return false
}

func (x *Value) GetBlob() []byte {
	if x, ok := x.GetV().(*Value_Blob); ok {
		return x.Blob
	}
	return nil
}

func (x *Value) GetL() *List {
	if x, ok := x.GetV().(*Value_L); ok {
		return x.L
	}
	return nil
}

func (x *Value) GetM() *Map {
	if x, ok := x.GetV().(*Value_M); ok {
		return x.M
	}
	return nil
}

func (x *Value) GetJson() *Json {
	if x, ok := x.GetV().(*Value_Json); ok {
		return x.Json
	}
	return nil
}

func (x *Value) GetGeo() string {
	if x, ok := x.GetV().(*Value_Geo); ok {
		return x.Geo
	}
	return ""
}

func (x *Value) GetHll() []byte {
	if x, ok := x.GetV().(*Value_Hll); ok {
		return x.Hll
	}
	return nil
}

func (x *Value) GetWildcard() bool {
	if x, ok := x.GetV().(*Value_Wildcard); ok {
		return x.Wildcard
	}
	return false
}

func (x *Value) GetInfinity() bool {
	if x, ok := x.GetV().(*Value_Infinity); ok {
		return x.Infinity
	}
	return false
}

type isValue_V interface {
	isValue_V()
}

type Value_Nil struct {
	Nil bool `protobuf:"varint,1,opt,name=nil,proto3,oneof"`
}

type Value_I struct {
	I int64 `protobuf:"varint,2,opt,name=i,proto3,oneof"`
}

type Value_F struct {
	F float64 `protobuf:"fixed64,3,opt,name=f,proto3,oneof"`
}

type Value_S struct {
	S string `protobuf:"bytes,4,opt,name=s,proto3,oneof"`
}

type Value_B struct {
	B bool `protobuf:"varint,5,opt,name=b,proto3,oneof"`
}

type Value_Blob struct {
	Blob []byte `protobuf:"bytes,6,opt,name=blob,proto3,oneof"`
}

type Value_L struct {
	L *List `protobuf:"bytes,7,opt,name=l,proto3,oneof"`
}

type Value_M struct {
	M *Map `protobuf:"bytes,8,opt,name=m,proto3,oneof"`
}

type Value_Json struct {
	Json *Json `protobuf:"bytes,9,opt,name=json,proto3,oneof"`
}

type Value_Geo struct {
	Geo string `protobuf:"bytes,10,opt,name=geo,proto3,oneof"`
}

type Value_Hll struct {
	Hll []byte `protobuf:"bytes,11,opt,name=hll,proto3,oneof"`
}

type Value_Wildcard struct {
	Wildcard bool `protobuf:"varint,12,opt,name=wildcard,proto3,oneof"`
}

type Value_Infinity struct {
	Infinity bool `protobuf:"varint,13,opt,name=infinity,proto3,oneof"`
}

func (*Value_Nil) isValue_V() {}

func (*Value_I) isValue_V() {}

func (*Value_F) isValue_V() {}

func (*Value_S) isValue_V() {}

func (*Value_B) isValue_V() {}

func (*Value_Blob) isValue_V() {}

func (*Value_L) isValue_V() {}

func (*Value_M) isValue_V() {}

func (*Value_Json) isValue_V() {}

func (*Value_Geo) isValue_V() {}

func (*Value_Hll) isValue_V() {}

func (*Value_Wildcard) isValue_V() {}

func (*Value_Infinity) isValue_V() {}

type Key struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Digest    []byte  `protobuf:"bytes,1,opt,name=digest,proto3,oneof" json:"digest,omitempty"`
	Namespace *string `protobuf:"bytes,2,opt,name=namespace,proto3,oneof" json:"namespace,omitempty"`
	Set       *string `protobuf:"bytes,3,opt,name=set,proto3,oneof" json:"set,omitempty"`
	Value     *Value  `protobuf:"bytes,4,opt,name=value,proto3,oneof" json:"value,omitempty"`
}

func (x *Key) Reset() {
	*x = Key{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Key) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Key) ProtoMessage() {}

func (x *Key) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Key.ProtoReflect.Descriptor instead.
func (*Key) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{16}
}

func (x *Key) GetDigest() []byte {
	if x != nil {
		return x.Digest
	}
	return nil
}

func (x *Key) GetNamespace() string {
	if x != nil && x.Namespace != nil {
		return *x.Namespace
	}
	return ""
}

func (x *Key) GetSet() string {
	if x != nil && x.Set != nil {
		return *x.Set
	}
	return ""
}

func (x *Key) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

type Record struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key        *Key              `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Generation uint32            `protobuf:"varint,2,opt,name=Generation,proto3" json:"Generation,omitempty"`
	Expiration uint32            `protobuf:"varint,3,opt,name=Expiration,proto3" json:"Expiration,omitempty"`
	Bins       map[string]*Value `protobuf:"bytes,4,rep,name=Bins,proto3" json:"Bins,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Record) Reset() {
	*x = Record{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Record) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Record) ProtoMessage() {}

func (x *Record) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Record.ProtoReflect.Descriptor instead.
func (*Record) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{17}
}

func (x *Record) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *Record) GetGeneration() uint32 {
	if x != nil {
		return x.Generation
	}
	return 0
}

func (x *Record) GetExpiration() uint32 {
	if x != nil {
		return x.Expiration
	}
	return 0
}

func (x *Record) GetBins() map[string]*Value {
	if x != nil {
		return x.Bins
	}
	return nil
}

// The Aerospike Error.
type Error struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Status of the corresponding request.
	//  if status equals 0
	//     The proxy received a valid response from Aerospike. The payload's
	//     result code should be used as the client result code.
	//  else
	//     The request failed at the proxy. This status should be used
	//     as the client result code.
	ResultCode int32 `protobuf:"varint,1,opt,name=resultCode,proto3" json:"resultCode,omitempty"`
	// This flag indicates that the write transaction may have completed,
	// even though the client sees an error.
	InDoubt bool `protobuf:"varint,2,opt,name=inDoubt,proto3" json:"inDoubt,omitempty"`
}

func (x *Error) Reset() {
	*x = Error{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Error) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Error) ProtoMessage() {}

func (x *Error) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Error.ProtoReflect.Descriptor instead.
func (*Error) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{18}
}

func (x *Error) GetResultCode() int32 {
	if x != nil {
		return x.ResultCode
	}
	return 0
}

func (x *Error) GetInDoubt() bool {
	if x != nil {
		return x.InDoubt
	}
	return false
}

// BatchRecord encasulates the Batch key and record result.
type BatchRecord struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Key.
	Key *Key `protobuf:"bytes,1,opt,name=key,proto3,oneof" json:"key,omitempty"`
	// Record result after batch command has completed.  Will be nil if record was not found
	// or an error occurred. See Error.
	Record *Record `protobuf:"bytes,2,opt,name=record,proto3,oneof" json:"record,omitempty"`
	// Encapsulates the error
	Error *Error `protobuf:"bytes,3,opt,name=error,proto3,oneof" json:"error,omitempty"`
}

func (x *BatchRecord) Reset() {
	*x = BatchRecord{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchRecord) ProtoMessage() {}

func (x *BatchRecord) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchRecord.ProtoReflect.Descriptor instead.
func (*BatchRecord) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{19}
}

func (x *BatchRecord) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *BatchRecord) GetRecord() *Record {
	if x != nil {
		return x.Record
	}
	return nil
}

func (x *BatchRecord) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

// CDTContext defines Nested CDT context. Identifies the location of nested list/map to apply the operation.
// for the current level.
// An array of CTX identifies location of the list/map on multiple
// levels on nesting.
type CDTContext struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *CDTContext) Reset() {
	*x = CDTContext{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CDTContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CDTContext) ProtoMessage() {}

func (x *CDTContext) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CDTContext.ProtoReflect.Descriptor instead.
func (*CDTContext) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{20}
}

func (x *CDTContext) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *CDTContext) GetValue() *Value {
	if x != nil {
		return x.Value
	}
	return nil
}

// Operation contains operation definition.
// This struct is used in client's operate() method.
type Operation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// OpType determines type of operation.
	OpType OperationType `protobuf:"varint,1,opt,name=opType,proto3,enum=com.aerospike.daemon.OperationType" json:"opType,omitempty"`
	// used in CDT commands
	OpSubType *int32 `protobuf:"varint,3,opt,name=opSubType,proto3,oneof" json:"opSubType,omitempty"`
	// CDT context for nested types
	Ctx []*CDTContext `protobuf:"bytes,4,rep,name=ctx,proto3" json:"ctx,omitempty"`
	// binName (Optional) determines the name of bin used in operation.
	BinName *string `protobuf:"bytes,5,opt,name=binName,proto3,oneof" json:"binName,omitempty"`
	// binValue (Optional) determines bin value used in operation.
	BinValue *Value `protobuf:"bytes,6,opt,name=binValue,proto3,oneof" json:"binValue,omitempty"`
}

func (x *Operation) Reset() {
	*x = Operation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Operation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Operation) ProtoMessage() {}

func (x *Operation) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Operation.ProtoReflect.Descriptor instead.
func (*Operation) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{21}
}

func (x *Operation) GetOpType() OperationType {
	if x != nil {
		return x.OpType
	}
	return OperationType_OperationTypeRead
}

func (x *Operation) GetOpSubType() int32 {
	if x != nil && x.OpSubType != nil {
		return *x.OpSubType
	}
	return 0
}

func (x *Operation) GetCtx() []*CDTContext {
	if x != nil {
		return x.Ctx
	}
	return nil
}

func (x *Operation) GetBinName() string {
	if x != nil && x.BinName != nil {
		return *x.BinName
	}
	return ""
}

func (x *Operation) GetBinValue() *Value {
	if x != nil {
		return x.BinValue
	}
	return nil
}

// BatchWrite encapsulates a batch key and read/write operations with write policy.
type BatchWrite struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BatchRecord *BatchRecord `protobuf:"bytes,1,opt,name=batchRecord,proto3" json:"batchRecord,omitempty"`
	// Optional write policy.
	Policy *BatchWritePolicy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	// Required operations for this key.
	Ops []*Operation `protobuf:"bytes,3,rep,name=ops,proto3" json:"ops,omitempty"`
}

func (x *BatchWrite) Reset() {
	*x = BatchWrite{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchWrite) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchWrite) ProtoMessage() {}

func (x *BatchWrite) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchWrite.ProtoReflect.Descriptor instead.
func (*BatchWrite) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{22}
}

func (x *BatchWrite) GetBatchRecord() *BatchRecord {
	if x != nil {
		return x.BatchRecord
	}
	return nil
}

func (x *BatchWrite) GetPolicy() *BatchWritePolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *BatchWrite) GetOps() []*Operation {
	if x != nil {
		return x.Ops
	}
	return nil
}

// BatchRead specifies the Key and bin names used in batch read commands
// where variable bins are needed for each key.
type BatchRead struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BatchRecord *BatchRecord `protobuf:"bytes,1,opt,name=batchRecord,proto3" json:"batchRecord,omitempty"`
	// Optional read policy.
	Policy *BatchReadPolicy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	// BinNames specifies the Bins to retrieve for this key.
	// BinNames are mutually exclusive with Ops.
	BinNames []string `protobuf:"bytes,3,rep,name=binNames,proto3" json:"binNames,omitempty"`
	// ReadAllBins defines what data should be read from the record.
	// If true, ignore binNames and read all bins.
	// If false and binNames are set, read specified binNames.
	// If false and binNames are not set, read record header (generation, expiration) only.
	ReadAllBins bool `protobuf:"varint,4,opt,name=readAllBins,proto3" json:"readAllBins,omitempty"`
	// Ops specifies the operations to perform for every key.
	// Ops are mutually exclusive with BinNames.
	// A binName can be emulated with `GetOp(binName)`
	// Supported by server v5.6.0+.
	Ops []*Operation `protobuf:"bytes,5,rep,name=ops,proto3" json:"ops,omitempty"`
}

func (x *BatchRead) Reset() {
	*x = BatchRead{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchRead) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchRead) ProtoMessage() {}

func (x *BatchRead) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchRead.ProtoReflect.Descriptor instead.
func (*BatchRead) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{23}
}

func (x *BatchRead) GetBatchRecord() *BatchRecord {
	if x != nil {
		return x.BatchRecord
	}
	return nil
}

func (x *BatchRead) GetPolicy() *BatchReadPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *BatchRead) GetBinNames() []string {
	if x != nil {
		return x.BinNames
	}
	return nil
}

func (x *BatchRead) GetReadAllBins() bool {
	if x != nil {
		return x.ReadAllBins
	}
	return false
}

func (x *BatchRead) GetOps() []*Operation {
	if x != nil {
		return x.Ops
	}
	return nil
}

// BatchDelete encapsulates a batch delete operation.
type BatchDelete struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BatchRecord *BatchRecord `protobuf:"bytes,1,opt,name=batchRecord,proto3" json:"batchRecord,omitempty"`
	// policy os the optional write policy.
	Policy *BatchDeletePolicy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
}

func (x *BatchDelete) Reset() {
	*x = BatchDelete{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchDelete) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchDelete) ProtoMessage() {}

func (x *BatchDelete) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchDelete.ProtoReflect.Descriptor instead.
func (*BatchDelete) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{24}
}

func (x *BatchDelete) GetBatchRecord() *BatchRecord {
	if x != nil {
		return x.BatchRecord
	}
	return nil
}

func (x *BatchDelete) GetPolicy() *BatchDeletePolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

// BatchUDF encapsulates a batch user defined function operation.
type BatchUDF struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BatchRecord *BatchRecord `protobuf:"bytes,1,opt,name=batchRecord,proto3" json:"batchRecord,omitempty"`
	// Optional UDF policy.
	Policy *BatchUDFPolicy `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	// Package or lua module name.
	PackageName string `protobuf:"bytes,3,opt,name=packageName,proto3" json:"packageName,omitempty"`
	// Lua function name.
	FunctionName string `protobuf:"bytes,4,opt,name=functionName,proto3" json:"functionName,omitempty"`
	// Optional arguments to lua function.
	FunctionArgs []*Value `protobuf:"bytes,5,rep,name=functionArgs,proto3" json:"functionArgs,omitempty"`
}

func (x *BatchUDF) Reset() {
	*x = BatchUDF{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchUDF) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchUDF) ProtoMessage() {}

func (x *BatchUDF) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchUDF.ProtoReflect.Descriptor instead.
func (*BatchUDF) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{25}
}

func (x *BatchUDF) GetBatchRecord() *BatchRecord {
	if x != nil {
		return x.BatchRecord
	}
	return nil
}

func (x *BatchUDF) GetPolicy() *BatchUDFPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *BatchUDF) GetPackageName() string {
	if x != nil {
		return x.PackageName
	}
	return ""
}

func (x *BatchUDF) GetFunctionName() string {
	if x != nil {
		return x.FunctionName
	}
	return ""
}

func (x *BatchUDF) GetFunctionArgs() []*Value {
	if x != nil {
		return x.FunctionArgs
	}
	return nil
}

// The response for KV commands.
type AerospikeSingleResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3,oneof" json:"error,omitempty"`
	// Aerospike wire format request payload.
	Record *Record `protobuf:"bytes,2,opt,name=record,proto3,oneof" json:"record,omitempty"`
}

func (x *AerospikeSingleResponse) Reset() {
	*x = AerospikeSingleResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeSingleResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeSingleResponse) ProtoMessage() {}

func (x *AerospikeSingleResponse) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeSingleResponse.ProtoReflect.Descriptor instead.
func (*AerospikeSingleResponse) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{26}
}

func (x *AerospikeSingleResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *AerospikeSingleResponse) GetRecord() *Record {
	if x != nil {
		return x.Record
	}
	return nil
}

type AerospikeGetRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy   *ReadPolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Key      *Key        `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	BinNames []string    `protobuf:"bytes,3,rep,name=binNames,proto3" json:"binNames,omitempty"`
}

func (x *AerospikeGetRequest) Reset() {
	*x = AerospikeGetRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeGetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeGetRequest) ProtoMessage() {}

func (x *AerospikeGetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeGetRequest.ProtoReflect.Descriptor instead.
func (*AerospikeGetRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{27}
}

func (x *AerospikeGetRequest) GetPolicy() *ReadPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeGetRequest) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *AerospikeGetRequest) GetBinNames() []string {
	if x != nil {
		return x.BinNames
	}
	return nil
}

type AerospikeGetHeaderRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy *ReadPolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Key    *Key        `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (x *AerospikeGetHeaderRequest) Reset() {
	*x = AerospikeGetHeaderRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeGetHeaderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeGetHeaderRequest) ProtoMessage() {}

func (x *AerospikeGetHeaderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeGetHeaderRequest.ProtoReflect.Descriptor instead.
func (*AerospikeGetHeaderRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{28}
}

func (x *AerospikeGetHeaderRequest) GetPolicy() *ReadPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeGetHeaderRequest) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

type AerospikeExistsRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy *ReadPolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Key    *Key        `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (x *AerospikeExistsRequest) Reset() {
	*x = AerospikeExistsRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeExistsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeExistsRequest) ProtoMessage() {}

func (x *AerospikeExistsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeExistsRequest.ProtoReflect.Descriptor instead.
func (*AerospikeExistsRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{29}
}

func (x *AerospikeExistsRequest) GetPolicy() *ReadPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeExistsRequest) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

// The response for KV commands.
type AerospikeExistsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error
	Error  *Error `protobuf:"bytes,1,opt,name=error,proto3,oneof" json:"error,omitempty"`
	Exists *bool  `protobuf:"varint,2,opt,name=exists,proto3,oneof" json:"exists,omitempty"`
}

func (x *AerospikeExistsResponse) Reset() {
	*x = AerospikeExistsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[30]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeExistsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeExistsResponse) ProtoMessage() {}

func (x *AerospikeExistsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[30]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeExistsResponse.ProtoReflect.Descriptor instead.
func (*AerospikeExistsResponse) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{30}
}

func (x *AerospikeExistsResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *AerospikeExistsResponse) GetExists() bool {
	if x != nil && x.Exists != nil {
		return *x.Exists
	}
	return false
}

type AerospikeDeleteRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy *WritePolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Key    *Key         `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (x *AerospikeDeleteRequest) Reset() {
	*x = AerospikeDeleteRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[31]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeDeleteRequest) ProtoMessage() {}

func (x *AerospikeDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[31]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeDeleteRequest.ProtoReflect.Descriptor instead.
func (*AerospikeDeleteRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{31}
}

func (x *AerospikeDeleteRequest) GetPolicy() *WritePolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeDeleteRequest) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

// The response for KV commands.
type AerospikeDeleteResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Error
	Error   *Error `protobuf:"bytes,1,opt,name=error,proto3,oneof" json:"error,omitempty"`
	Existed *bool  `protobuf:"varint,2,opt,name=existed,proto3,oneof" json:"existed,omitempty"`
}

func (x *AerospikeDeleteResponse) Reset() {
	*x = AerospikeDeleteResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[32]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeDeleteResponse) ProtoMessage() {}

func (x *AerospikeDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[32]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeDeleteResponse.ProtoReflect.Descriptor instead.
func (*AerospikeDeleteResponse) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{32}
}

func (x *AerospikeDeleteResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *AerospikeDeleteResponse) GetExisted() bool {
	if x != nil && x.Existed != nil {
		return *x.Existed
	}
	return false
}

type AerospikeTouchRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy *WritePolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Key    *Key         `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (x *AerospikeTouchRequest) Reset() {
	*x = AerospikeTouchRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[33]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeTouchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeTouchRequest) ProtoMessage() {}

func (x *AerospikeTouchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[33]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeTouchRequest.ProtoReflect.Descriptor instead.
func (*AerospikeTouchRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{33}
}

func (x *AerospikeTouchRequest) GetPolicy() *WritePolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeTouchRequest) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

type AerospikePutRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy *WritePolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Key    *Key         `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Bins   []*Bin       `protobuf:"bytes,3,rep,name=Bins,proto3" json:"Bins,omitempty"`
}

func (x *AerospikePutRequest) Reset() {
	*x = AerospikePutRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[34]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikePutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikePutRequest) ProtoMessage() {}

func (x *AerospikePutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[34]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikePutRequest.ProtoReflect.Descriptor instead.
func (*AerospikePutRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{34}
}

func (x *AerospikePutRequest) GetPolicy() *WritePolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikePutRequest) GetKey() *Key {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *AerospikePutRequest) GetBins() []*Bin {
	if x != nil {
		return x.Bins
	}
	return nil
}

type BatchOperate struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Br *BatchRead   `protobuf:"bytes,1,opt,name=br,proto3,oneof" json:"br,omitempty"`
	Bw *BatchWrite  `protobuf:"bytes,2,opt,name=bw,proto3,oneof" json:"bw,omitempty"`
	Bd *BatchDelete `protobuf:"bytes,3,opt,name=bd,proto3,oneof" json:"bd,omitempty"`
	Bu *BatchUDF    `protobuf:"bytes,4,opt,name=bu,proto3,oneof" json:"bu,omitempty"`
}

func (x *BatchOperate) Reset() {
	*x = BatchOperate{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[35]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BatchOperate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchOperate) ProtoMessage() {}

func (x *BatchOperate) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[35]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchOperate.ProtoReflect.Descriptor instead.
func (*BatchOperate) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{35}
}

func (x *BatchOperate) GetBr() *BatchRead {
	if x != nil {
		return x.Br
	}
	return nil
}

func (x *BatchOperate) GetBw() *BatchWrite {
	if x != nil {
		return x.Bw
	}
	return nil
}

func (x *BatchOperate) GetBd() *BatchDelete {
	if x != nil {
		return x.Bd
	}
	return nil
}

func (x *BatchOperate) GetBu() *BatchUDF {
	if x != nil {
		return x.Bu
	}
	return nil
}

type AerospikeBatchOperateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy  *BatchPolicy    `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Records []*BatchOperate `protobuf:"bytes,2,rep,name=records,proto3" json:"records,omitempty"`
}

func (x *AerospikeBatchOperateRequest) Reset() {
	*x = AerospikeBatchOperateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[36]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeBatchOperateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeBatchOperateRequest) ProtoMessage() {}

func (x *AerospikeBatchOperateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[36]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeBatchOperateRequest.ProtoReflect.Descriptor instead.
func (*AerospikeBatchOperateRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{36}
}

func (x *AerospikeBatchOperateRequest) GetPolicy() *BatchPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeBatchOperateRequest) GetRecords() []*BatchOperate {
	if x != nil {
		return x.Records
	}
	return nil
}

type AerospikeBatchOperateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Error   *Error         `protobuf:"bytes,1,opt,name=error,proto3,oneof" json:"error,omitempty"`
	Records []*BatchRecord `protobuf:"bytes,2,rep,name=records,proto3" json:"records,omitempty"`
}

func (x *AerospikeBatchOperateResponse) Reset() {
	*x = AerospikeBatchOperateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[37]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeBatchOperateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeBatchOperateResponse) ProtoMessage() {}

func (x *AerospikeBatchOperateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[37]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeBatchOperateResponse.ProtoReflect.Descriptor instead.
func (*AerospikeBatchOperateResponse) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{37}
}

func (x *AerospikeBatchOperateResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

func (x *AerospikeBatchOperateResponse) GetRecords() []*BatchRecord {
	if x != nil {
		return x.Records
	}
	return nil
}

type AerospikeCreateIndexRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy              *WritePolicy        `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Namespace           string              `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	SetName             string              `protobuf:"bytes,3,opt,name=setName,proto3" json:"setName,omitempty"`
	IndexName           string              `protobuf:"bytes,4,opt,name=indexName,proto3" json:"indexName,omitempty"`
	BinName             string              `protobuf:"bytes,5,opt,name=binName,proto3" json:"binName,omitempty"`
	IndexType           IndexType           `protobuf:"varint,6,opt,name=indexType,proto3,enum=com.aerospike.daemon.IndexType" json:"indexType,omitempty"`
	IndexCollectionType IndexCollectionType `protobuf:"varint,7,opt,name=indexCollectionType,proto3,enum=com.aerospike.daemon.IndexCollectionType" json:"indexCollectionType,omitempty"`
	Ctx                 []*CDTContext       `protobuf:"bytes,8,rep,name=ctx,proto3" json:"ctx,omitempty"`
}

func (x *AerospikeCreateIndexRequest) Reset() {
	*x = AerospikeCreateIndexRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[38]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeCreateIndexRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeCreateIndexRequest) ProtoMessage() {}

func (x *AerospikeCreateIndexRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[38]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeCreateIndexRequest.ProtoReflect.Descriptor instead.
func (*AerospikeCreateIndexRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{38}
}

func (x *AerospikeCreateIndexRequest) GetPolicy() *WritePolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeCreateIndexRequest) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *AerospikeCreateIndexRequest) GetSetName() string {
	if x != nil {
		return x.SetName
	}
	return ""
}

func (x *AerospikeCreateIndexRequest) GetIndexName() string {
	if x != nil {
		return x.IndexName
	}
	return ""
}

func (x *AerospikeCreateIndexRequest) GetBinName() string {
	if x != nil {
		return x.BinName
	}
	return ""
}

func (x *AerospikeCreateIndexRequest) GetIndexType() IndexType {
	if x != nil {
		return x.IndexType
	}
	return IndexType_IndexTypeNumeric
}

func (x *AerospikeCreateIndexRequest) GetIndexCollectionType() IndexCollectionType {
	if x != nil {
		return x.IndexCollectionType
	}
	return IndexCollectionType_IndexCollectionTypeDefault
}

func (x *AerospikeCreateIndexRequest) GetCtx() []*CDTContext {
	if x != nil {
		return x.Ctx
	}
	return nil
}

type AerospikeCreateIndexResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Error *Error `protobuf:"bytes,1,opt,name=error,proto3,oneof" json:"error,omitempty"`
}

func (x *AerospikeCreateIndexResponse) Reset() {
	*x = AerospikeCreateIndexResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[39]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeCreateIndexResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeCreateIndexResponse) ProtoMessage() {}

func (x *AerospikeCreateIndexResponse) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[39]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeCreateIndexResponse.ProtoReflect.Descriptor instead.
func (*AerospikeCreateIndexResponse) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{39}
}

func (x *AerospikeCreateIndexResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type AerospikeDropIndexRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy    *WritePolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Namespace string       `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	SetName   string       `protobuf:"bytes,3,opt,name=setName,proto3" json:"setName,omitempty"`
	IndexName string       `protobuf:"bytes,4,opt,name=indexName,proto3" json:"indexName,omitempty"`
}

func (x *AerospikeDropIndexRequest) Reset() {
	*x = AerospikeDropIndexRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[40]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeDropIndexRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeDropIndexRequest) ProtoMessage() {}

func (x *AerospikeDropIndexRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[40]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeDropIndexRequest.ProtoReflect.Descriptor instead.
func (*AerospikeDropIndexRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{40}
}

func (x *AerospikeDropIndexRequest) GetPolicy() *WritePolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeDropIndexRequest) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *AerospikeDropIndexRequest) GetSetName() string {
	if x != nil {
		return x.SetName
	}
	return ""
}

func (x *AerospikeDropIndexRequest) GetIndexName() string {
	if x != nil {
		return x.IndexName
	}
	return ""
}

type AerospikeDropIndexResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Error *Error `protobuf:"bytes,1,opt,name=error,proto3,oneof" json:"error,omitempty"`
}

func (x *AerospikeDropIndexResponse) Reset() {
	*x = AerospikeDropIndexResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[41]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeDropIndexResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeDropIndexResponse) ProtoMessage() {}

func (x *AerospikeDropIndexResponse) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[41]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeDropIndexResponse.ProtoReflect.Descriptor instead.
func (*AerospikeDropIndexResponse) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{41}
}

func (x *AerospikeDropIndexResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type AerospikeTruncateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Policy      *InfoPolicy `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Namespace   string      `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	SetName     string      `protobuf:"bytes,3,opt,name=setName,proto3" json:"setName,omitempty"`
	BeforeNanos *int64      `protobuf:"varint,4,opt,name=before_nanos,json=beforeNanos,proto3,oneof" json:"before_nanos,omitempty"`
}

func (x *AerospikeTruncateRequest) Reset() {
	*x = AerospikeTruncateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[42]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeTruncateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeTruncateRequest) ProtoMessage() {}

func (x *AerospikeTruncateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[42]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeTruncateRequest.ProtoReflect.Descriptor instead.
func (*AerospikeTruncateRequest) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{42}
}

func (x *AerospikeTruncateRequest) GetPolicy() *InfoPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *AerospikeTruncateRequest) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *AerospikeTruncateRequest) GetSetName() string {
	if x != nil {
		return x.SetName
	}
	return ""
}

func (x *AerospikeTruncateRequest) GetBeforeNanos() int64 {
	if x != nil && x.BeforeNanos != nil {
		return *x.BeforeNanos
	}
	return 0
}

type AerospikeTruncateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Error *Error `protobuf:"bytes,1,opt,name=error,proto3,oneof" json:"error,omitempty"`
}

func (x *AerospikeTruncateResponse) Reset() {
	*x = AerospikeTruncateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[43]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AerospikeTruncateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AerospikeTruncateResponse) ProtoMessage() {}

func (x *AerospikeTruncateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[43]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AerospikeTruncateResponse.ProtoReflect.Descriptor instead.
func (*AerospikeTruncateResponse) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{43}
}

func (x *AerospikeTruncateResponse) GetError() *Error {
	if x != nil {
		return x.Error
	}
	return nil
}

type BackgroundExecutePolicy struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Read policy for AP (availability) namespaces.
	Replica ReplicaPolicy `protobuf:"varint,1,opt,name=replica,proto3,enum=com.aerospike.daemon.ReplicaPolicy" json:"replica,omitempty"`
	// Read policy for SC (strong consistency) namespaces.
	ReadModeAP ReadModeAP `protobuf:"varint,2,opt,name=readModeAP,proto3,enum=com.aerospike.daemon.ReadModeAP" json:"readModeAP,omitempty"`
	// Replica algorithm used to determine the target node
	// for a single record command.
	// Scan and scan are not affected by replica algorithms.
	ReadModeSC ReadModeSC `protobuf:"varint,3,opt,name=readModeSC,proto3,enum=com.aerospike.daemon.ReadModeSC" json:"readModeSC,omitempty"`
	// Use zlib compression on command buffers sent to the server and responses received
	// from the server when the buffer size is greater than 128 bytes.
	// This option will increase cpu and memory usage (for extra compressed buffers),but
	// decrease the size of data sent over the network.
	Compress bool `protobuf:"varint,4,opt,name=compress,proto3" json:"compress,omitempty"`
	// Optional expression filter. If filterExp exists and evaluates to false, the
	// transaction is ignored.
	Expression []byte `protobuf:"bytes,5,opt,name=expression,proto3,oneof" json:"expression,omitempty"`
	// Total transaction timeout in milliseconds.
	// Default for all other commands: 1000ms
	TotalTimeout *uint32 `protobuf:"varint,6,opt,name=totalTimeout,proto3,oneof" json:"totalTimeout,omitempty"`
	// Send user defined key in addition to hash digest on both reads and writes.
	// If the key is sent on a write, the key will be stored with the record on
	// the server.
	// <p>
	// Default: false (do not send the user defined key)
	SendKey *bool `protobuf:"varint,7,opt,name=sendKey,proto3,oneof" json:"sendKey,omitempty"`
	// Qualify how to handle writes where the record already exists.
	//
	// Default: RecordExistsAction.UPDATE
	RecordExistsAction *RecordExistsAction `protobuf:"varint,8,opt,name=recordExistsAction,proto3,enum=com.aerospike.daemon.RecordExistsAction,oneof" json:"recordExistsAction,omitempty"`
	// Qualify how to handle record writes based on record generation. The default (NONE)
	// indicates that the generation is not used to restrict writes.
	//
	// The server does not support this field for UDF execute() calls. The read-modify-write
	// usage model can still be enforced inside the UDF code itself.
	//
	// Default: GenerationPolicy.NONE
	GenerationPolicy *GenerationPolicy `protobuf:"varint,9,opt,name=generationPolicy,proto3,enum=com.aerospike.daemon.GenerationPolicy,oneof" json:"generationPolicy,omitempty"`
	// Desired consistency guarantee when committing a transaction on the server. The default
	// (COMMIT_ALL) indicates that the server should wait for master and all replica commits to
	// be successful before returning success to the client.
	//
	// Default: CommitLevel.COMMIT_ALL
	CommitLevel *CommitLevel `protobuf:"varint,10,opt,name=commitLevel,proto3,enum=com.aerospike.daemon.CommitLevel,oneof" json:"commitLevel,omitempty"`
	// Expected generation. Generation is the number of times a record has been modified
	// (including creation) on the server. If a write operation is creating a record,
	// the expected generation would be <code>0</code>. This field is only relevant when
	// generationPolicy is not NONE.
	//
	// The server does not support this field for UDF execute() calls. The read-modify-write
	// usage model can still be enforced inside the UDF code itself.
	//
	// Default: 0
	Generation *uint32 `protobuf:"varint,11,opt,name=generation,proto3,oneof" json:"generation,omitempty"`
	// Record expiration. Also known as ttl (time to live).
	// Seconds record will live before being removed by the server.
	//
	// Expiration values:
	//
	//  - -2: Do not change ttl when record is updated.
	//  - -1: Never expire.
	//  - 0: Default to namespace configuration variable "default-ttl" on the server.
	//  - &gt; 0: Actual ttl in seconds.<br>
	//
	// Default: 0
	Expiration *uint32 `protobuf:"varint,12,opt,name=expiration,proto3,oneof" json:"expiration,omitempty"`
	// For client operate(), return a result for every operation.
	//
	// Some operations do not return results by default (ListOperation.clear() for example).
	// This can make it difficult to determine the desired result offset in the returned
	// bin's result list.
	//
	// Setting respondAllOps to true makes it easier to identify the desired result offset
	// (result offset equals bin's operate sequence).  If there is a map operation in operate(),
	// respondAllOps will be forced to true for that operate() call.
	//
	// Default: false
	RespondAllOps *bool `protobuf:"varint,13,opt,name=respondAllOps,proto3,oneof" json:"respondAllOps,omitempty"`
	// If the transaction results in a record deletion, leave a tombstone for the record.
	// This prevents deleted records from reappearing after node failures.
	// Valid for Aerospike Server Enterprise Edition 3.10+ only.
	//
	// Default: false (do not tombstone deleted records).
	DurableDelete *bool `protobuf:"varint,14,opt,name=durableDelete,proto3,oneof" json:"durableDelete,omitempty"`
	// Operate in XDR mode.  Some external connectors may need to emulate an XDR client.
	// If enabled, an XDR bit is set for writes in the wire protocol.
	//
	// Default: false.
	Xdr *bool `protobuf:"varint,15,opt,name=xdr,proto3,oneof" json:"xdr,omitempty"`
}

func (x *BackgroundExecutePolicy) Reset() {
	*x = BackgroundExecutePolicy{}
	if protoimpl.UnsafeEnabled {
		mi := &file_asld_kvs_proto_msgTypes[44]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BackgroundExecutePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BackgroundExecutePolicy) ProtoMessage() {}

func (x *BackgroundExecutePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_asld_kvs_proto_msgTypes[44]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BackgroundExecutePolicy.ProtoReflect.Descriptor instead.
func (*BackgroundExecutePolicy) Descriptor() ([]byte, []int) {
	return file_asld_kvs_proto_rawDescGZIP(), []int{44}
}

func (x *BackgroundExecutePolicy) GetReplica() ReplicaPolicy {
	if x != nil {
		return x.Replica
	}
	return ReplicaPolicy_SEQUENCE
}

func (x *BackgroundExecutePolicy) GetReadModeAP() ReadModeAP {
	if x != nil {
		return x.ReadModeAP
	}
	return ReadModeAP_ReadModeAPOne
}

func (x *BackgroundExecutePolicy) GetReadModeSC() ReadModeSC {
	if x != nil {
		return x.ReadModeSC
	}
	return ReadModeSC_ReadModeSCSession
}

func (x *BackgroundExecutePolicy) GetCompress() bool {
	if x != nil {
		return x.Compress
	}
	return false
}

func (x *BackgroundExecutePolicy) GetExpression() []byte {
	if x != nil {
		return x.Expression
	}
	return nil
}

func (x *BackgroundExecutePolicy) GetTotalTimeout() uint32 {
	if x != nil && x.TotalTimeout != nil {
		return *x.TotalTimeout
	}
	return 0
}

func (x *BackgroundExecutePolicy) GetSendKey() bool {
	if x != nil && x.SendKey != nil {
		return *x.SendKey
	}
	return false
}

func (x *BackgroundExecutePolicy) GetRecordExistsAction() RecordExistsAction {
	if x != nil && x.RecordExistsAction != nil {
		return *x.RecordExistsAction
	}
	return RecordExistsAction_UPDATE
}

func (x *BackgroundExecutePolicy) GetGenerationPolicy() GenerationPolicy {
	if x != nil && x.GenerationPolicy != nil {
		return *x.GenerationPolicy
	}
	return GenerationPolicy_NONE
}

func (x *BackgroundExecutePolicy) GetCommitLevel() CommitLevel {
	if x != nil && x.CommitLevel != nil {
		return *x.CommitLevel
	}
	return CommitLevel_COMMIT_ALL
}

func (x *BackgroundExecutePolicy) GetGeneration() uint32 {
	if x != nil && x.Generation != nil {
		return *x.Generation
	}
	return 0
}

func (x *BackgroundExecutePolicy) GetExpiration() uint32 {
	if x != nil && x.Expiration != nil {
		return *x.Expiration
	}
	return 0
}

func (x *BackgroundExecutePolicy) GetRespondAllOps() bool {
	if x != nil && x.RespondAllOps != nil {
		return *x.RespondAllOps
	}
	return false
}

func (x *BackgroundExecutePolicy) GetDurableDelete() bool {
	if x != nil && x.DurableDelete != nil {
		return *x.DurableDelete
	}
	return false
}

func (x *BackgroundExecutePolicy) GetXdr() bool {
	if x != nil && x.Xdr != nil {
		return *x.Xdr
	}
	return false
}

var File_asld_kvs_proto protoreflect.FileDescriptor

var file_asld_kvs_proto_rawDesc = []byte{
	0x0a, 0x0e, 0x61, 0x73, 0x6c, 0x64, 0x5f, 0x6b, 0x76, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x14, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e,
	0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x22, 0xe7, 0x02, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x72, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x32, 0x0a, 0x03, 0x63, 0x6d, 0x64, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x48,
	0x00, 0x52, 0x03, 0x63, 0x6d, 0x64, 0x88, 0x01, 0x01, 0x12, 0x32, 0x0a, 0x03, 0x76, 0x61, 0x6c,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x48, 0x01, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x88, 0x01, 0x01, 0x12, 0x37, 0x0a,
	0x03, 0x62, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x48, 0x02, 0x52, 0x03,
	0x62, 0x69, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x19, 0x0a, 0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x03, 0x48, 0x03, 0x52, 0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x88, 0x01,
	0x01, 0x12, 0x3a, 0x0a, 0x06, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x1d, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65,
	0x48, 0x04, 0x52, 0x06, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x88, 0x01, 0x01, 0x12, 0x34, 0x0a,
	0x04, 0x65, 0x78, 0x70, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x04, 0x65,
	0x78, 0x70, 0x73, 0x42, 0x06, 0x0a, 0x04, 0x5f, 0x63, 0x6d, 0x64, 0x42, 0x06, 0x0a, 0x04, 0x5f,
	0x76, 0x61, 0x6c, 0x42, 0x06, 0x0a, 0x04, 0x5f, 0x62, 0x69, 0x6e, 0x42, 0x08, 0x0a, 0x06, 0x5f,
	0x66, 0x6c, 0x61, 0x67, 0x73, 0x42, 0x09, 0x0a, 0x07, 0x5f, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65,
	0x22, 0x99, 0x05, 0x0a, 0x0a, 0x52, 0x65, 0x61, 0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12,
	0x51, 0x0a, 0x10, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
	0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e,
	0x2e, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x10, 0x66,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x88,
	0x01, 0x01, 0x12, 0x40, 0x0a, 0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x50,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65,
	0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x50, 0x52, 0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f,
	0x64, 0x65, 0x41, 0x50, 0x12, 0x40, 0x0a, 0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65,
	0x53, 0x43, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x52, 0x0a, 0x72, 0x65, 0x61, 0x64,
	0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x12, 0x22, 0x0a, 0x0c, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x54,
	0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0c, 0x74, 0x6f,
	0x74, 0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x24, 0x0a, 0x0d, 0x73, 0x6f,
	0x63, 0x6b, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x0d, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74,
	0x12, 0x1e, 0x0a, 0x0a, 0x6d, 0x61, 0x78, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x6d, 0x61, 0x78, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73,
	0x12, 0x30, 0x0a, 0x13, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x42, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e,
	0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x52, 0x13, 0x73,
	0x6c, 0x65, 0x65, 0x70, 0x42, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x52, 0x65, 0x74, 0x72, 0x69,
	0x65, 0x73, 0x12, 0x28, 0x0a, 0x0f, 0x73, 0x6c, 0x65, 0x65, 0x70, 0x4d, 0x75, 0x6c, 0x74, 0x69,
	0x70, 0x6c, 0x69, 0x65, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0f, 0x73, 0x6c, 0x65,
	0x65, 0x70, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72, 0x12, 0x4c, 0x0a, 0x21,
	0x65, 0x78, 0x69, 0x74, 0x46, 0x61, 0x73, 0x74, 0x4f, 0x6e, 0x45, 0x78, 0x68, 0x61, 0x75, 0x73,
	0x74, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6f,
	0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x21, 0x65, 0x78, 0x69, 0x74, 0x46, 0x61, 0x73,
	0x74, 0x4f, 0x6e, 0x45, 0x78, 0x68, 0x61, 0x75, 0x73, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6e, 0x6e,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6f, 0x6c, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65,
	0x6e, 0x64, 0x4b, 0x65, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x65, 0x6e,
	0x64, 0x4b, 0x65, 0x79, 0x12, 0x26, 0x0a, 0x0e, 0x75, 0x73, 0x65, 0x43, 0x6f, 0x6d, 0x70, 0x72,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x75, 0x73,
	0x65, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x0d,
	0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x0c, 0x20,
	0x01, 0x28, 0x0e, 0x32, 0x23, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x70, 0x6c, 0x69,
	0x63, 0x61, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x0d, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63,
	0x61, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x42, 0x13, 0x0a, 0x11, 0x5f, 0x66, 0x69, 0x6c, 0x74,
	0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xcc, 0x03, 0x0a,
	0x0b, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x38, 0x0a, 0x06,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63,
	0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65,
	0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x61, 0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x58, 0x0a, 0x12, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64,
	0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x28, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64,
	0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x12, 0x72, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x12, 0x52, 0x0a, 0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x52, 0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x12, 0x43, 0x0a, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65,
	0x76, 0x65, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
	0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e,
	0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x0b, 0x63, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x1e, 0x0a, 0x0a, 0x67, 0x65, 0x6e,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x67,
	0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x0a, 0x0a, 0x65, 0x78, 0x70,
	0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x65,
	0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x10, 0x72, 0x65, 0x73,
	0x70, 0x6f, 0x6e, 0x64, 0x50, 0x65, 0x72, 0x45, 0x61, 0x63, 0x68, 0x4f, 0x70, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x10, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x50, 0x65, 0x72, 0x45,
	0x61, 0x63, 0x68, 0x4f, 0x70, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65,
	0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x64, 0x75,
	0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x22, 0x26, 0x0a, 0x0a, 0x49,
	0x6e, 0x66, 0x6f, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65,
	0x6f, 0x75, 0x74, 0x22, 0xff, 0x01, 0x0a, 0x0f, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x61,
	0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x52, 0x0a, 0x11, 0x66, 0x69, 0x6c, 0x74, 0x65,
	0x72, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x10, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x45, 0x78,
	0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x40, 0x0a, 0x0a, 0x72,
	0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x50, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e,
	0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41,
	0x50, 0x52, 0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x50, 0x12, 0x40, 0x0a,
	0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64,
	0x65, 0x53, 0x43, 0x52, 0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x42,
	0x14, 0x0a, 0x12, 0x5f, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xef, 0x03, 0x0a, 0x10, 0x42, 0x61, 0x74, 0x63, 0x68, 0x57,
	0x72, 0x69, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x52, 0x0a, 0x11, 0x66, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f,
	0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x10, 0x66, 0x69, 0x6c, 0x74, 0x65,
	0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x58,
	0x0a, 0x12, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x41, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x52, 0x12, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x45, 0x78, 0x69, 0x73,
	0x74, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x43, 0x0a, 0x0b, 0x63, 0x6f, 0x6d, 0x6d,
	0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c,
	0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x52, 0x0a,
	0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x47,
	0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52,
	0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x12, 0x1e, 0x0a, 0x0a, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x1e, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65,
	0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6c,
	0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b,
	0x65, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65,
	0x79, 0x42, 0x14, 0x0a, 0x12, 0x5f, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xf6, 0x02, 0x0a, 0x11, 0x42, 0x61, 0x74, 0x63,
	0x68, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x52, 0x0a,
	0x11, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x10, 0x66, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x88, 0x01,
	0x01, 0x12, 0x43, 0x0a, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69,
	0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x52, 0x0a, 0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x26, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x1e, 0x0a, 0x0a, 0x67, 0x65,
	0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a,
	0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x75,
	0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x0d, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
	0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x42, 0x14, 0x0a, 0x12, 0x5f, 0x66,
	0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x22, 0x9f, 0x02, 0x0a, 0x0e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x55, 0x44, 0x46, 0x50, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x12, 0x52, 0x0a, 0x11, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x65, 0x78,
	0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20,
	0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64,
	0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x48, 0x00, 0x52, 0x10, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x43, 0x0a, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69,
	0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x63,
	0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65,
	0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52,
	0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x1e, 0x0a, 0x0a,
	0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d,
	0x64, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0d, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65,
	0x74, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x42, 0x14, 0x0a, 0x12,
	0x5f, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x22, 0xae, 0x02, 0x0a, 0x0b, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x12, 0x38, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x61, 0x64, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x2d, 0x0a, 0x0f,
	0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x0f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72,
	0x65, 0x6e, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x88, 0x01, 0x01, 0x12, 0x20, 0x0a, 0x0b, 0x61,
	0x6c, 0x6c, 0x6f, 0x77, 0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x0b, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x26, 0x0a,
	0x0e, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x49, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x53, 0x53, 0x44, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x49, 0x6e, 0x6c, 0x69,
	0x6e, 0x65, 0x53, 0x53, 0x44, 0x12, 0x26, 0x0a, 0x0e, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64,
	0x41, 0x6c, 0x6c, 0x4b, 0x65, 0x79, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x72,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x41, 0x6c, 0x6c, 0x4b, 0x65, 0x79, 0x73, 0x12, 0x30, 0x0a,
	0x13, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x52, 0x65, 0x73,
	0x75, 0x6c, 0x74, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x13, 0x41, 0x6c, 0x6c, 0x6f,
	0x77, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x42,
	0x12, 0x0a, 0x10, 0x5f, 0x63, 0x6f, 0x6e, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x4e, 0x6f,
	0x64, 0x65, 0x73, 0x22, 0x4c, 0x0a, 0x03, 0x42, 0x69, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x31,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x22, 0x31, 0x0a, 0x04, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x01, 0x6c, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73,
	0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75,
	0x65, 0x52, 0x01, 0x6c, 0x22, 0x60, 0x0a, 0x08, 0x4d, 0x61, 0x70, 0x45, 0x6e, 0x74, 0x72, 0x79,
	0x12, 0x29, 0x0a, 0x01, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x01, 0x6b, 0x12, 0x29, 0x0a, 0x01, 0x76,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x52, 0x01, 0x76, 0x22, 0x33, 0x0a, 0x03, 0x4d, 0x61, 0x70, 0x12, 0x2c, 0x0a,
	0x01, 0x6d, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x4d, 0x61, 0x70, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x01, 0x6d, 0x22, 0x44, 0x0a, 0x09, 0x4a,
	0x73, 0x6f, 0x6e, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x0c, 0x0a, 0x01, 0x6b, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x01, 0x6b, 0x12, 0x29, 0x0a, 0x01, 0x76, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x01,
	0x76, 0x22, 0x35, 0x0a, 0x04, 0x4a, 0x73, 0x6f, 0x6e, 0x12, 0x2d, 0x0a, 0x01, 0x6a, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73,
	0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4a, 0x73, 0x6f, 0x6e,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x01, 0x6a, 0x22, 0xe3, 0x02, 0x0a, 0x05, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x12, 0x12, 0x0a, 0x03, 0x6e, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x48,
	0x00, 0x52, 0x03, 0x6e, 0x69, 0x6c, 0x12, 0x0e, 0x0a, 0x01, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x03, 0x48, 0x00, 0x52, 0x01, 0x69, 0x12, 0x0e, 0x0a, 0x01, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x01, 0x48, 0x00, 0x52, 0x01, 0x66, 0x12, 0x0e, 0x0a, 0x01, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x09, 0x48, 0x00, 0x52, 0x01, 0x73, 0x12, 0x0e, 0x0a, 0x01, 0x62, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x08, 0x48, 0x00, 0x52, 0x01, 0x62, 0x12, 0x14, 0x0a, 0x04, 0x62, 0x6c, 0x6f, 0x62, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x04, 0x62, 0x6c, 0x6f, 0x62, 0x12, 0x2a, 0x0a, 0x01,
	0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4c,
	0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x01, 0x6c, 0x12, 0x29, 0x0a, 0x01, 0x6d, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4d, 0x61, 0x70, 0x48, 0x00,
	0x52, 0x01, 0x6d, 0x12, 0x30, 0x0a, 0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x18, 0x09, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1a, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4a, 0x73, 0x6f, 0x6e, 0x48, 0x00, 0x52,
	0x04, 0x6a, 0x73, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x03, 0x67, 0x65, 0x6f, 0x18, 0x0a, 0x20, 0x01,
	0x28, 0x09, 0x48, 0x00, 0x52, 0x03, 0x67, 0x65, 0x6f, 0x12, 0x12, 0x0a, 0x03, 0x68, 0x6c, 0x6c,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x03, 0x68, 0x6c, 0x6c, 0x12, 0x1c, 0x0a,
	0x08, 0x77, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x48,
	0x00, 0x52, 0x08, 0x77, 0x69, 0x6c, 0x64, 0x63, 0x61, 0x72, 0x64, 0x12, 0x1c, 0x0a, 0x08, 0x69,
	0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x79, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52,
	0x08, 0x69, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x79, 0x42, 0x03, 0x0a, 0x01, 0x76, 0x22, 0xbf,
	0x01, 0x0a, 0x03, 0x4b, 0x65, 0x79, 0x12, 0x1b, 0x0a, 0x06, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x06, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74,
	0x88, 0x01, 0x01, 0x12, 0x21, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x01, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70,
	0x61, 0x63, 0x65, 0x88, 0x01, 0x01, 0x12, 0x15, 0x0a, 0x03, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x09, 0x48, 0x02, 0x52, 0x03, 0x73, 0x65, 0x74, 0x88, 0x01, 0x01, 0x12, 0x36, 0x0a,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63,
	0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65,
	0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x48, 0x03, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x88, 0x01, 0x01, 0x42, 0x09, 0x0a, 0x07, 0x5f, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74,
	0x42, 0x0c, 0x0a, 0x0a, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x42, 0x06,
	0x0a, 0x04, 0x5f, 0x73, 0x65, 0x74, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x22, 0x87, 0x02, 0x0a, 0x06, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x2b, 0x0a, 0x03, 0x6b,
	0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x4b, 0x65, 0x79, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x1e, 0x0a, 0x0a, 0x47, 0x65, 0x6e, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x47, 0x65,
	0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x69,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x45, 0x78,
	0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3a, 0x0a, 0x04, 0x42, 0x69, 0x6e, 0x73,
	0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x2e, 0x42, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04,
	0x42, 0x69, 0x6e, 0x73, 0x1a, 0x54, 0x0a, 0x09, 0x42, 0x69, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72,
	0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x6b, 0x65, 0x79, 0x12, 0x31, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x41, 0x0a, 0x05, 0x45, 0x72,
	0x72, 0x6f, 0x72, 0x12, 0x1e, 0x0a, 0x0a, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x43, 0x6f, 0x64,
	0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x43,
	0x6f, 0x64, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x69, 0x6e, 0x44, 0x6f, 0x75, 0x62, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x6e, 0x44, 0x6f, 0x75, 0x62, 0x74, 0x22, 0xcf, 0x01,
	0x0a, 0x0b, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x30, 0x0a,
	0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x4b, 0x65, 0x79, 0x48, 0x00, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x88, 0x01, 0x01, 0x12,
	0x39, 0x0a, 0x06, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1c, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e,
	0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x48, 0x01, 0x52,
	0x06, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x88, 0x01, 0x01, 0x12, 0x36, 0x0a, 0x05, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
	0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e,
	0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x48, 0x02, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x88,
	0x01, 0x01, 0x42, 0x06, 0x0a, 0x04, 0x5f, 0x6b, 0x65, 0x79, 0x42, 0x09, 0x0a, 0x07, 0x5f, 0x72,
	0x65, 0x63, 0x6f, 0x72, 0x64, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22,
	0x4f, 0x0a, 0x0a, 0x43, 0x44, 0x54, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x12, 0x0e, 0x0a,
	0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x02, 0x69, 0x64, 0x12, 0x31, 0x0a,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63,
	0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65,
	0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x22, 0xa3, 0x02, 0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3b,
	0x0a, 0x06, 0x6f, 0x70, 0x54, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x23,
	0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64,
	0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x06, 0x6f, 0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x21, 0x0a, 0x09, 0x6f,
	0x70, 0x53, 0x75, 0x62, 0x54, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00,
	0x52, 0x09, 0x6f, 0x70, 0x53, 0x75, 0x62, 0x54, 0x79, 0x70, 0x65, 0x88, 0x01, 0x01, 0x12, 0x32,
	0x0a, 0x03, 0x63, 0x74, 0x78, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x43, 0x44, 0x54, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x52, 0x03, 0x63,
	0x74, 0x78, 0x12, 0x1d, 0x0a, 0x07, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x09, 0x48, 0x01, 0x52, 0x07, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x88, 0x01,
	0x01, 0x12, 0x3c, 0x0a, 0x08, 0x62, 0x69, 0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x06, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65,
	0x48, 0x02, 0x52, 0x08, 0x62, 0x69, 0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x88, 0x01, 0x01, 0x42,
	0x0c, 0x0a, 0x0a, 0x5f, 0x6f, 0x70, 0x53, 0x75, 0x62, 0x54, 0x79, 0x70, 0x65, 0x42, 0x0a, 0x0a,
	0x08, 0x5f, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x42, 0x0b, 0x0a, 0x09, 0x5f, 0x62, 0x69,
	0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xc4, 0x01, 0x0a, 0x0a, 0x42, 0x61, 0x74, 0x63, 0x68,
	0x57, 0x72, 0x69, 0x74, 0x65, 0x12, 0x43, 0x0a, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x0b, 0x62,
	0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x3e, 0x0a, 0x06, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x31, 0x0a, 0x03, 0x6f, 0x70,
	0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x6f, 0x70, 0x73, 0x22, 0x80, 0x02,
	0x0a, 0x09, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x61, 0x64, 0x12, 0x43, 0x0a, 0x0b, 0x62,
	0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63,
	0x6f, 0x72, 0x64, 0x52, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64,
	0x12, 0x3d, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x25, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x61,
	0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12,
	0x1a, 0x0a, 0x08, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x08, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x72,
	0x65, 0x61, 0x64, 0x41, 0x6c, 0x6c, 0x42, 0x69, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x0b, 0x72, 0x65, 0x61, 0x64, 0x41, 0x6c, 0x6c, 0x42, 0x69, 0x6e, 0x73, 0x12, 0x31, 0x0a,
	0x03, 0x6f, 0x70, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x6f, 0x70, 0x73,
	0x22, 0x93, 0x01, 0x0a, 0x0b, 0x42, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
	0x12, 0x43, 0x0a, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f,
	0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74,
	0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x52,
	0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x3f, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f,
	0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74,
	0x63, 0x68, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x22, 0x94, 0x02, 0x0a, 0x08, 0x42, 0x61, 0x74, 0x63, 0x68,
	0x55, 0x44, 0x46, 0x12, 0x43, 0x0a, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f,
	0x72, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x52, 0x0b, 0x62, 0x61, 0x74,
	0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x12, 0x3c, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x42, 0x61, 0x74, 0x63, 0x68, 0x55, 0x44, 0x46, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x20, 0x0a, 0x0b, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67,
	0x65, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x61, 0x63,
	0x6b, 0x61, 0x67, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x66, 0x75, 0x6e, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c,
	0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x3f, 0x0a, 0x0c,
	0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x72, 0x67, 0x73, 0x18, 0x05, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52,
	0x0c, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x72, 0x67, 0x73, 0x22, 0xa1, 0x01,
	0x0a, 0x17, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x53, 0x69, 0x6e, 0x67, 0x6c,
	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x05, 0x65, 0x72, 0x72,
	0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x45, 0x72, 0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x88, 0x01,
	0x01, 0x12, 0x39, 0x0a, 0x06, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x48,
	0x01, 0x52, 0x06, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x88, 0x01, 0x01, 0x42, 0x08, 0x0a, 0x06,
	0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x42, 0x09, 0x0a, 0x07, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72,
	0x64, 0x22, 0x98, 0x01, 0x0a, 0x13, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x47,
	0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x38, 0x0a, 0x06, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
	0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e,
	0x2e, 0x52, 0x65, 0x61, 0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c,
	0x69, 0x63, 0x79, 0x12, 0x2b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x1a, 0x0a, 0x08, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x08, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x22, 0x82, 0x01, 0x0a,
	0x19, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x47, 0x65, 0x74, 0x48, 0x65, 0x61,
	0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x38, 0x0a, 0x06, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x52, 0x65, 0x61, 0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x12, 0x2b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x6b, 0x65,
	0x79, 0x22, 0x7f, 0x0a, 0x16, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x45, 0x78,
	0x69, 0x73, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x38, 0x0a, 0x06, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x61, 0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x2b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x6b,
	0x65, 0x79, 0x22, 0x83, 0x01, 0x0a, 0x17, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36,
	0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x05, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x88, 0x01, 0x01, 0x12, 0x1b, 0x0a, 0x06, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x48, 0x01, 0x52, 0x06, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73,
	0x88, 0x01, 0x01, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x42, 0x09, 0x0a,
	0x07, 0x5f, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73, 0x22, 0x80, 0x01, 0x0a, 0x16, 0x41, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x2b,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x4b, 0x65, 0x79, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x22, 0x86, 0x01, 0x0a, 0x17,
	0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72,
	0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x88, 0x01, 0x01, 0x12,
	0x1d, 0x0a, 0x07, 0x65, 0x78, 0x69, 0x73, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08,
	0x48, 0x01, 0x52, 0x07, 0x65, 0x78, 0x69, 0x73, 0x74, 0x65, 0x64, 0x88, 0x01, 0x01, 0x42, 0x08,
	0x0a, 0x06, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x42, 0x0a, 0x0a, 0x08, 0x5f, 0x65, 0x78, 0x69,
	0x73, 0x74, 0x65, 0x64, 0x22, 0x7f, 0x0a, 0x15, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x54, 0x6f, 0x75, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a,
	0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x2b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f,
	0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4b, 0x65, 0x79,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x22, 0xac, 0x01, 0x0a, 0x13, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x50, 0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a,
	0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x2b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f,
	0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x4b, 0x65, 0x79,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2d, 0x0a, 0x04, 0x42, 0x69, 0x6e, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x69, 0x6e, 0x52, 0x04,
	0x42, 0x69, 0x6e, 0x73, 0x22, 0x84, 0x02, 0x0a, 0x0c, 0x42, 0x61, 0x74, 0x63, 0x68, 0x4f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x65, 0x12, 0x34, 0x0a, 0x02, 0x62, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65,
	0x61, 0x64, 0x48, 0x00, 0x52, 0x02, 0x62, 0x72, 0x88, 0x01, 0x01, 0x12, 0x35, 0x0a, 0x02, 0x62,
	0x77, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42,
	0x61, 0x74, 0x63, 0x68, 0x57, 0x72, 0x69, 0x74, 0x65, 0x48, 0x01, 0x52, 0x02, 0x62, 0x77, 0x88,
	0x01, 0x01, 0x12, 0x36, 0x0a, 0x02, 0x62, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21,
	0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64,
	0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x44, 0x65, 0x6c, 0x65, 0x74,
	0x65, 0x48, 0x02, 0x52, 0x02, 0x62, 0x64, 0x88, 0x01, 0x01, 0x12, 0x33, 0x0a, 0x02, 0x62, 0x75,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61,
	0x74, 0x63, 0x68, 0x55, 0x44, 0x46, 0x48, 0x03, 0x52, 0x02, 0x62, 0x75, 0x88, 0x01, 0x01, 0x42,
	0x05, 0x0a, 0x03, 0x5f, 0x62, 0x72, 0x42, 0x05, 0x0a, 0x03, 0x5f, 0x62, 0x77, 0x42, 0x05, 0x0a,
	0x03, 0x5f, 0x62, 0x64, 0x42, 0x05, 0x0a, 0x03, 0x5f, 0x62, 0x75, 0x22, 0x97, 0x01, 0x0a, 0x1c,
	0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x4f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x06,
	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x63,
	0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65,
	0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52,
	0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x3c, 0x0a, 0x07, 0x72, 0x65, 0x63, 0x6f, 0x72,
	0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x42, 0x61, 0x74, 0x63, 0x68, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x65, 0x52, 0x07, 0x72, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x73, 0x22, 0x9e, 0x01, 0x0a, 0x1d, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x65, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72,
	0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x88, 0x01, 0x01, 0x12,
	0x3b, 0x0a, 0x07, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x42, 0x61, 0x74, 0x63, 0x68, 0x52, 0x65, 0x63,
	0x6f, 0x72, 0x64, 0x52, 0x07, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x42, 0x08, 0x0a, 0x06,
	0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x98, 0x03, 0x0a, 0x1b, 0x41, 0x65, 0x72, 0x6f, 0x73,
	0x70, 0x69, 0x6b, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x52,
	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x57, 0x72,
	0x69, 0x74, 0x65, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12,
	0x18, 0x0a, 0x07, 0x73, 0x65, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x07, 0x73, 0x65, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6e, 0x64,
	0x65, 0x78, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x69, 0x6e,
	0x64, 0x65, 0x78, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x62, 0x69, 0x6e, 0x4e, 0x61,
	0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x62, 0x69, 0x6e, 0x4e, 0x61, 0x6d,
	0x65, 0x12, 0x3d, 0x0a, 0x09, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x54, 0x79, 0x70, 0x65, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x1f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73,
	0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x49, 0x6e, 0x64, 0x65,
	0x78, 0x54, 0x79, 0x70, 0x65, 0x52, 0x09, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x5b, 0x0a, 0x13, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x29, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63,
	0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x13, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x43,
	0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x32, 0x0a,
	0x03, 0x63, 0x74, 0x78, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x43, 0x44, 0x54, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x52, 0x03, 0x63, 0x74,
	0x78, 0x22, 0x60, 0x0a, 0x1c, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x43, 0x72,
	0x65, 0x61, 0x74, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x12, 0x36, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x48, 0x00, 0x52,
	0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x88, 0x01, 0x01, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x65, 0x72,
	0x72, 0x6f, 0x72, 0x22, 0xac, 0x01, 0x0a, 0x19, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x44, 0x72, 0x6f, 0x70, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x39, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x21, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x1c, 0x0a, 0x09,
	0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65,
	0x74, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x74,
	0x4e, 0x61, 0x6d, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x4e, 0x61, 0x6d,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x4e, 0x61,
	0x6d, 0x65, 0x22, 0x5e, 0x0a, 0x1a, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x44,
	0x72, 0x6f, 0x70, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x12, 0x36, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e,
	0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x05,
	0x65, 0x72, 0x72, 0x6f, 0x72, 0x88, 0x01, 0x01, 0x42, 0x08, 0x0a, 0x06, 0x5f, 0x65, 0x72, 0x72,
	0x6f, 0x72, 0x22, 0xc5, 0x01, 0x0a, 0x18, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65,
	0x54, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x38, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e,
	0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x50, 0x6f, 0x6c, 0x69, 0x63,
	0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d,
	0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61,
	0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x65, 0x74, 0x4e, 0x61,
	0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x65, 0x74, 0x4e, 0x61, 0x6d,
	0x65, 0x12, 0x26, 0x0a, 0x0c, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x5f, 0x6e, 0x61, 0x6e, 0x6f,
	0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x48, 0x00, 0x52, 0x0b, 0x62, 0x65, 0x66, 0x6f, 0x72,
	0x65, 0x4e, 0x61, 0x6e, 0x6f, 0x73, 0x88, 0x01, 0x01, 0x42, 0x0f, 0x0a, 0x0d, 0x5f, 0x62, 0x65,
	0x66, 0x6f, 0x72, 0x65, 0x5f, 0x6e, 0x61, 0x6e, 0x6f, 0x73, 0x22, 0x5d, 0x0a, 0x19, 0x41, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x54, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72,
	0x72, 0x6f, 0x72, 0x48, 0x00, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x88, 0x01, 0x01, 0x42,
	0x08, 0x0a, 0x06, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22, 0xd0, 0x07, 0x0a, 0x17, 0x42, 0x61,
	0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x50,
	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x3d, 0x0a, 0x07, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x23, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65,
	0x70, 0x6c, 0x69, 0x63, 0x61, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x07, 0x72, 0x65, 0x70,
	0x6c, 0x69, 0x63, 0x61, 0x12, 0x40, 0x0a, 0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65,
	0x41, 0x50, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x50, 0x52, 0x0a, 0x72, 0x65, 0x61, 0x64,
	0x4d, 0x6f, 0x64, 0x65, 0x41, 0x50, 0x12, 0x40, 0x0a, 0x0a, 0x72, 0x65, 0x61, 0x64, 0x4d, 0x6f,
	0x64, 0x65, 0x53, 0x43, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x20, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x52, 0x0a, 0x72, 0x65,
	0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6d, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x63, 0x6f, 0x6d, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x12, 0x23, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x0a, 0x65, 0x78, 0x70, 0x72,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x27, 0x0a, 0x0c, 0x74, 0x6f, 0x74,
	0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x48,
	0x01, 0x52, 0x0c, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x88,
	0x01, 0x01, 0x12, 0x1d, 0x0a, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x18, 0x07, 0x20,
	0x01, 0x28, 0x08, 0x48, 0x02, 0x52, 0x07, 0x73, 0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x88, 0x01,
	0x01, 0x12, 0x5d, 0x0a, 0x12, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74,
	0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x45, 0x78, 0x69, 0x73, 0x74,
	0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x03, 0x52, 0x12, 0x72, 0x65, 0x63, 0x6f, 0x72,
	0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01,
	0x12, 0x57, 0x0a, 0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f,
	0x6c, 0x69, 0x63, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x48, 0x04, 0x52, 0x10, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x88, 0x01, 0x01, 0x12, 0x48, 0x0a, 0x0b, 0x63, 0x6f, 0x6d,
	0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x21,
	0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64,
	0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65,
	0x6c, 0x48, 0x05, 0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c,
	0x88, 0x01, 0x01, 0x12, 0x23, 0x0a, 0x0a, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x06, 0x52, 0x0a, 0x67, 0x65, 0x6e, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x23, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x48, 0x07, 0x52, 0x0a,
	0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x88, 0x01, 0x01, 0x12, 0x29, 0x0a,
	0x0d, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x41, 0x6c, 0x6c, 0x4f, 0x70, 0x73, 0x18, 0x0d,
	0x20, 0x01, 0x28, 0x08, 0x48, 0x08, 0x52, 0x0d, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x41,
	0x6c, 0x6c, 0x4f, 0x70, 0x73, 0x88, 0x01, 0x01, 0x12, 0x29, 0x0a, 0x0d, 0x64, 0x75, 0x72, 0x61,
	0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x48,
	0x09, 0x52, 0x0d, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
	0x88, 0x01, 0x01, 0x12, 0x15, 0x0a, 0x03, 0x78, 0x64, 0x72, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x08,
	0x48, 0x0a, 0x52, 0x03, 0x78, 0x64, 0x72, 0x88, 0x01, 0x01, 0x42, 0x0d, 0x0a, 0x0b, 0x5f, 0x65,
	0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x42, 0x0f, 0x0a, 0x0d, 0x5f, 0x74, 0x6f,
	0x74, 0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x42, 0x0a, 0x0a, 0x08, 0x5f, 0x73,
	0x65, 0x6e, 0x64, 0x4b, 0x65, 0x79, 0x42, 0x15, 0x0a, 0x13, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72,
	0x64, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x13, 0x0a,
	0x11, 0x5f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x42, 0x0e, 0x0a, 0x0c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76,
	0x65, 0x6c, 0x42, 0x0d, 0x0a, 0x0b, 0x5f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x42, 0x0d, 0x0a, 0x0b, 0x5f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x42, 0x10, 0x0a, 0x0e, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x64, 0x41, 0x6c, 0x6c, 0x4f,
	0x70, 0x73, 0x42, 0x10, 0x0a, 0x0e, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65,
	0x6c, 0x65, 0x74, 0x65, 0x42, 0x06, 0x0a, 0x04, 0x5f, 0x78, 0x64, 0x72, 0x2a, 0x9e, 0x02, 0x0a,
	0x0c, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a,
	0x10, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x4e, 0x75, 0x6c,
	0x6c, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x13, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54,
	0x79, 0x70, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x10, 0x01, 0x12, 0x15, 0x0a, 0x11,
	0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x46, 0x6c, 0x6f, 0x61,
	0x74, 0x10, 0x02, 0x12, 0x16, 0x0a, 0x12, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54,
	0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x10, 0x03, 0x12, 0x14, 0x0a, 0x10, 0x50,
	0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x42, 0x6c, 0x6f, 0x62, 0x10,
	0x04, 0x12, 0x16, 0x0a, 0x12, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70,
	0x65, 0x44, 0x69, 0x67, 0x65, 0x73, 0x74, 0x10, 0x06, 0x12, 0x14, 0x0a, 0x10, 0x50, 0x61, 0x72,
	0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x42, 0x6f, 0x6f, 0x6c, 0x10, 0x11, 0x12,
	0x13, 0x0a, 0x0f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x48,
	0x4c, 0x4c, 0x10, 0x12, 0x12, 0x13, 0x0a, 0x0f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65,
	0x54, 0x79, 0x70, 0x65, 0x4d, 0x61, 0x70, 0x10, 0x13, 0x12, 0x14, 0x0a, 0x10, 0x50, 0x61, 0x72,
	0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x10, 0x14, 0x12,
	0x13, 0x0a, 0x0f, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x4c,
	0x44, 0x54, 0x10, 0x15, 0x12, 0x17, 0x0a, 0x13, 0x50, 0x61, 0x72, 0x74, 0x69, 0x63, 0x6c, 0x65,
	0x54, 0x79, 0x70, 0x65, 0x47, 0x65, 0x6f, 0x4a, 0x73, 0x6f, 0x6e, 0x10, 0x17, 0x2a, 0xb1, 0x01,
	0x0a, 0x07, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x78, 0x70,
	0x54, 0x79, 0x70, 0x65, 0x4e, 0x69, 0x6c, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x45, 0x78, 0x70,
	0x54, 0x79, 0x70, 0x65, 0x42, 0x6f, 0x6f, 0x6c, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x78,
	0x70, 0x54, 0x79, 0x70, 0x65, 0x49, 0x6e, 0x74, 0x10, 0x02, 0x12, 0x11, 0x0a, 0x0d, 0x45, 0x78,
	0x70, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x10, 0x03, 0x12, 0x0f, 0x0a,
	0x0b, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x10, 0x04, 0x12, 0x0e,
	0x0a, 0x0a, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65, 0x4d, 0x61, 0x70, 0x10, 0x05, 0x12, 0x0f,
	0x0a, 0x0b, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65, 0x42, 0x6c, 0x6f, 0x62, 0x10, 0x06, 0x12,
	0x10, 0x0a, 0x0c, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x10,
	0x07, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65, 0x47, 0x65, 0x6f, 0x10,
	0x08, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x54, 0x79, 0x70, 0x65, 0x48, 0x6c, 0x6c, 0x10,
	0x09, 0x2a, 0x9f, 0x07, 0x0a, 0x05, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x12, 0x10, 0x0a, 0x0c, 0x45,
	0x78, 0x70, 0x4f, 0x70, 0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x10, 0x00, 0x12, 0x0b, 0x0a,
	0x07, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x45, 0x71, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x45, 0x78,
	0x70, 0x4f, 0x70, 0x4e, 0x65, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x45, 0x78, 0x70, 0x4f, 0x70,
	0x47, 0x74, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x47, 0x65, 0x10,
	0x04, 0x12, 0x0b, 0x0a, 0x07, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4c, 0x74, 0x10, 0x05, 0x12, 0x0b,
	0x0a, 0x07, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4c, 0x65, 0x10, 0x06, 0x12, 0x0e, 0x0a, 0x0a, 0x45,
	0x78, 0x70, 0x4f, 0x70, 0x52, 0x65, 0x67, 0x65, 0x78, 0x10, 0x07, 0x12, 0x0c, 0x0a, 0x08, 0x45,
	0x78, 0x70, 0x4f, 0x70, 0x47, 0x65, 0x6f, 0x10, 0x08, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70,
	0x4f, 0x70, 0x41, 0x6e, 0x64, 0x10, 0x10, 0x12, 0x0b, 0x0a, 0x07, 0x45, 0x78, 0x70, 0x4f, 0x70,
	0x4f, 0x72, 0x10, 0x11, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4e, 0x6f, 0x74,
	0x10, 0x12, 0x12, 0x12, 0x0a, 0x0e, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x45, 0x78, 0x63, 0x6c, 0x75,
	0x73, 0x69, 0x76, 0x65, 0x10, 0x13, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x41,
	0x64, 0x64, 0x10, 0x14, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x53, 0x75, 0x62,
	0x10, 0x15, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4d, 0x75, 0x6c, 0x10, 0x16,
	0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x44, 0x69, 0x76, 0x10, 0x17, 0x12, 0x0c,
	0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x50, 0x6f, 0x77, 0x10, 0x18, 0x12, 0x0c, 0x0a, 0x08,
	0x45, 0x78, 0x70, 0x4f, 0x70, 0x4c, 0x6f, 0x67, 0x10, 0x19, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78,
	0x70, 0x4f, 0x70, 0x4d, 0x6f, 0x64, 0x10, 0x1a, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f,
	0x70, 0x41, 0x62, 0x73, 0x10, 0x1b, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x46,
	0x6c, 0x6f, 0x6f, 0x72, 0x10, 0x1c, 0x12, 0x0d, 0x0a, 0x09, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x43,
	0x65, 0x69, 0x6c, 0x10, 0x1d, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x54, 0x6f,
	0x49, 0x6e, 0x74, 0x10, 0x1e, 0x12, 0x10, 0x0a, 0x0c, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x54, 0x6f,
	0x46, 0x6c, 0x6f, 0x61, 0x74, 0x10, 0x1f, 0x12, 0x0f, 0x0a, 0x0b, 0x45, 0x78, 0x70, 0x4f, 0x70,
	0x49, 0x6e, 0x74, 0x41, 0x6e, 0x64, 0x10, 0x20, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x78, 0x70, 0x4f,
	0x70, 0x49, 0x6e, 0x74, 0x4f, 0x72, 0x10, 0x21, 0x12, 0x0f, 0x0a, 0x0b, 0x45, 0x78, 0x70, 0x4f,
	0x70, 0x49, 0x6e, 0x74, 0x58, 0x6f, 0x72, 0x10, 0x22, 0x12, 0x0f, 0x0a, 0x0b, 0x45, 0x78, 0x70,
	0x4f, 0x70, 0x49, 0x6e, 0x74, 0x4e, 0x6f, 0x74, 0x10, 0x23, 0x12, 0x12, 0x0a, 0x0e, 0x45, 0x78,
	0x70, 0x4f, 0x70, 0x49, 0x6e, 0x74, 0x4c, 0x53, 0x68, 0x69, 0x66, 0x74, 0x10, 0x24, 0x12, 0x12,
	0x0a, 0x0e, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x49, 0x6e, 0x74, 0x52, 0x53, 0x68, 0x69, 0x66, 0x74,
	0x10, 0x25, 0x12, 0x13, 0x0a, 0x0f, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x49, 0x6e, 0x74, 0x41, 0x52,
	0x53, 0x68, 0x69, 0x66, 0x74, 0x10, 0x26, 0x12, 0x11, 0x0a, 0x0d, 0x45, 0x78, 0x70, 0x4f, 0x70,
	0x49, 0x6e, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x10, 0x27, 0x12, 0x11, 0x0a, 0x0d, 0x45, 0x78,
	0x70, 0x4f, 0x70, 0x49, 0x6e, 0x74, 0x4c, 0x53, 0x63, 0x61, 0x6e, 0x10, 0x28, 0x12, 0x11, 0x0a,
	0x0d, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x49, 0x6e, 0x74, 0x52, 0x53, 0x63, 0x61, 0x6e, 0x10, 0x29,
	0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4d, 0x69, 0x6e, 0x10, 0x32, 0x12, 0x0c,
	0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4d, 0x61, 0x78, 0x10, 0x33, 0x12, 0x15, 0x0a, 0x11,
	0x45, 0x78, 0x70, 0x4f, 0x70, 0x44, 0x69, 0x67, 0x65, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x75, 0x6c,
	0x6f, 0x10, 0x40, 0x12, 0x13, 0x0a, 0x0f, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x44, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x10, 0x41, 0x12, 0x13, 0x0a, 0x0f, 0x45, 0x78, 0x70, 0x4f,
	0x70, 0x4c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x10, 0x42, 0x12, 0x14, 0x0a,
	0x10, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x55, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x10, 0x43, 0x12, 0x11, 0x0a, 0x0d, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x56, 0x6f, 0x69, 0x64,
	0x54, 0x69, 0x6d, 0x65, 0x10, 0x44, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x54,
	0x74, 0x6c, 0x10, 0x45, 0x12, 0x10, 0x0a, 0x0c, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x53, 0x65, 0x74,
	0x4e, 0x61, 0x6d, 0x65, 0x10, 0x46, 0x12, 0x12, 0x0a, 0x0e, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4b,
	0x65, 0x79, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x10, 0x47, 0x12, 0x14, 0x0a, 0x10, 0x45, 0x78,
	0x70, 0x4f, 0x70, 0x49, 0x73, 0x54, 0x6f, 0x6d, 0x62, 0x73, 0x74, 0x6f, 0x6e, 0x65, 0x10, 0x48,
	0x12, 0x13, 0x0a, 0x0f, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x53,
	0x69, 0x7a, 0x65, 0x10, 0x49, 0x12, 0x13, 0x0a, 0x0f, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x52, 0x65,
	0x63, 0x6f, 0x72, 0x64, 0x53, 0x69, 0x7a, 0x65, 0x10, 0x4a, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78,
	0x70, 0x4f, 0x70, 0x4b, 0x65, 0x79, 0x10, 0x50, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f,
	0x70, 0x42, 0x69, 0x6e, 0x10, 0x51, 0x12, 0x10, 0x0a, 0x0c, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x42,
	0x69, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x10, 0x52, 0x12, 0x0d, 0x0a, 0x09, 0x45, 0x78, 0x70, 0x4f,
	0x70, 0x43, 0x6f, 0x6e, 0x64, 0x10, 0x7b, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70,
	0x56, 0x61, 0x72, 0x10, 0x7c, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x4c, 0x65,
	0x74, 0x10, 0x7d, 0x12, 0x0f, 0x0a, 0x0b, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x51, 0x75, 0x6f, 0x74,
	0x65, 0x64, 0x10, 0x7e, 0x12, 0x0d, 0x0a, 0x09, 0x45, 0x78, 0x70, 0x4f, 0x70, 0x43, 0x61, 0x6c,
	0x6c, 0x10, 0x7f, 0x2a, 0x32, 0x0a, 0x0a, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41,
	0x50, 0x12, 0x11, 0x0a, 0x0d, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x41, 0x50, 0x4f,
	0x6e, 0x65, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65,
	0x41, 0x50, 0x41, 0x6c, 0x6c, 0x10, 0x01, 0x2a, 0x78, 0x0a, 0x0a, 0x52, 0x65, 0x61, 0x64, 0x4d,
	0x6f, 0x64, 0x65, 0x53, 0x43, 0x12, 0x15, 0x0a, 0x11, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64,
	0x65, 0x53, 0x43, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x10, 0x00, 0x12, 0x17, 0x0a, 0x13,
	0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72,
	0x69, 0x7a, 0x65, 0x10, 0x01, 0x12, 0x1a, 0x0a, 0x16, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64,
	0x65, 0x53, 0x43, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x10,
	0x02, 0x12, 0x1e, 0x0a, 0x1a, 0x52, 0x65, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x53, 0x43, 0x41,
	0x6c, 0x6c, 0x6f, 0x77, 0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x10,
	0x03, 0x2a, 0x59, 0x0a, 0x0d, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x50, 0x6f, 0x6c, 0x69,
	0x63, 0x79, 0x12, 0x0c, 0x0a, 0x08, 0x53, 0x45, 0x51, 0x55, 0x45, 0x4e, 0x43, 0x45, 0x10, 0x00,
	0x12, 0x0a, 0x0a, 0x06, 0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d,
	0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x4f, 0x4c, 0x45, 0x53, 0x10, 0x02, 0x12,
	0x0f, 0x0a, 0x0b, 0x50, 0x52, 0x45, 0x46, 0x45, 0x52, 0x5f, 0x52, 0x41, 0x43, 0x4b, 0x10, 0x03,
	0x12, 0x0a, 0x0a, 0x06, 0x52, 0x41, 0x4e, 0x44, 0x4f, 0x4d, 0x10, 0x04, 0x2a, 0x3a, 0x0a, 0x10,
	0x43, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x4c, 0x65, 0x76, 0x65, 0x6c,
	0x12, 0x12, 0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x4f,
	0x6e, 0x65, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e, 0x43, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x65,
	0x6e, 0x63, 0x79, 0x41, 0x6c, 0x6c, 0x10, 0x01, 0x2a, 0x63, 0x0a, 0x09, 0x49, 0x6e, 0x64, 0x65,
	0x78, 0x54, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x10, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x54, 0x79,
	0x70, 0x65, 0x4e, 0x75, 0x6d, 0x65, 0x72, 0x69, 0x63, 0x10, 0x00, 0x12, 0x13, 0x0a, 0x0f, 0x49,
	0x6e, 0x64, 0x65, 0x78, 0x54, 0x79, 0x70, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x10, 0x01,
	0x12, 0x11, 0x0a, 0x0d, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x54, 0x79, 0x70, 0x65, 0x42, 0x6c, 0x6f,
	0x62, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x54, 0x79, 0x70, 0x65,
	0x47, 0x65, 0x6f, 0x32, 0x44, 0x53, 0x70, 0x68, 0x65, 0x72, 0x65, 0x10, 0x03, 0x2a, 0x94, 0x01,
	0x0a, 0x13, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1e, 0x0a, 0x1a, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x43, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x66, 0x61,
	0x75, 0x6c, 0x74, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x43, 0x6f,
	0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x4c, 0x69, 0x73, 0x74,
	0x10, 0x01, 0x12, 0x1e, 0x0a, 0x1a, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x4d, 0x61, 0x70, 0x4b, 0x65, 0x79, 0x73,
	0x10, 0x02, 0x12, 0x20, 0x0a, 0x1c, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x43, 0x6f, 0x6c, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x4d, 0x61, 0x70, 0x56, 0x61, 0x6c, 0x75,
	0x65, 0x73, 0x10, 0x03, 0x2a, 0x47, 0x0a, 0x08, 0x41, 0x75, 0x74, 0x68, 0x4d, 0x6f, 0x64, 0x65,
	0x12, 0x14, 0x0a, 0x10, 0x41, 0x75, 0x74, 0x68, 0x4d, 0x6f, 0x64, 0x65, 0x49, 0x6e, 0x74, 0x65,
	0x72, 0x6e, 0x61, 0x6c, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x41, 0x75, 0x74, 0x68, 0x4d, 0x6f,
	0x64, 0x65, 0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x10, 0x01, 0x12, 0x0f, 0x0a, 0x0b,
	0x41, 0x75, 0x74, 0x68, 0x4d, 0x6f, 0x64, 0x65, 0x50, 0x4b, 0x49, 0x10, 0x02, 0x2a, 0x45, 0x0a,
	0x0d, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1a,
	0x0a, 0x16, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x55,
	0x6e, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x65, 0x64, 0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x4c, 0x69,
	0x73, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x65, 0x64, 0x10, 0x01, 0x2a, 0x66, 0x0a, 0x0c, 0x4d, 0x61, 0x70, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a, 0x15, 0x4d, 0x61, 0x70, 0x4f, 0x72, 0x64, 0x65, 0x72,
	0x54, 0x79, 0x70, 0x65, 0x55, 0x6e, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x65, 0x64, 0x10, 0x00, 0x12,
	0x1a, 0x0a, 0x16, 0x4d, 0x61, 0x70, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x4b,
	0x65, 0x79, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x65, 0x64, 0x10, 0x01, 0x12, 0x1f, 0x0a, 0x1b, 0x4d,
	0x61, 0x70, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x4b, 0x65, 0x79, 0x56, 0x61,
	0x6c, 0x75, 0x65, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x65, 0x64, 0x10, 0x03, 0x2a, 0xe3, 0x03, 0x0a,
	0x0d, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x15,
	0x0a, 0x11, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52,
	0x65, 0x61, 0x64, 0x10, 0x00, 0x12, 0x1b, 0x0a, 0x17, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x65, 0x61, 0x64, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72,
	0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54,
	0x79, 0x70, 0x65, 0x57, 0x72, 0x69, 0x74, 0x65, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x4f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x43, 0x64, 0x74, 0x52, 0x65,
	0x61, 0x64, 0x10, 0x03, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x54, 0x79, 0x70, 0x65, 0x43, 0x64, 0x74, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x10, 0x04,
	0x12, 0x18, 0x0a, 0x14, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70,
	0x65, 0x4d, 0x61, 0x70, 0x52, 0x65, 0x61, 0x64, 0x10, 0x05, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x4d, 0x61, 0x70, 0x4d, 0x6f,
	0x64, 0x69, 0x66, 0x79, 0x10, 0x06, 0x12, 0x14, 0x0a, 0x10, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x41, 0x64, 0x64, 0x10, 0x07, 0x12, 0x18, 0x0a, 0x14,
	0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x45, 0x78, 0x70,
	0x52, 0x65, 0x61, 0x64, 0x10, 0x08, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x45, 0x78, 0x70, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79,
	0x10, 0x09, 0x12, 0x17, 0x0a, 0x13, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54,
	0x79, 0x70, 0x65, 0x41, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x10, 0x0a, 0x12, 0x18, 0x0a, 0x14, 0x4f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x50, 0x72, 0x65, 0x70,
	0x65, 0x6e, 0x64, 0x10, 0x0b, 0x12, 0x16, 0x0a, 0x12, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x54, 0x6f, 0x75, 0x63, 0x68, 0x10, 0x0c, 0x12, 0x18, 0x0a,
	0x14, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x42, 0x69,
	0x74, 0x52, 0x65, 0x61, 0x64, 0x10, 0x0d, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x42, 0x69, 0x74, 0x4d, 0x6f, 0x64, 0x69, 0x66,
	0x79, 0x10, 0x0e, 0x12, 0x17, 0x0a, 0x13, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x54, 0x79, 0x70, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x10, 0x0f, 0x12, 0x18, 0x0a, 0x14,
	0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x48, 0x6c, 0x6c,
	0x52, 0x65, 0x61, 0x64, 0x10, 0x10, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x48, 0x6c, 0x6c, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79,
	0x10, 0x11, 0x2a, 0x61, 0x0a, 0x12, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x45, 0x78, 0x69, 0x73,
	0x74, 0x73, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0a, 0x0a, 0x06, 0x55, 0x50, 0x44, 0x41,
	0x54, 0x45, 0x10, 0x00, 0x12, 0x0f, 0x0a, 0x0b, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x4f,
	0x4e, 0x4c, 0x59, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x45, 0x50, 0x4c, 0x41, 0x43, 0x45,
	0x10, 0x02, 0x12, 0x10, 0x0a, 0x0c, 0x52, 0x45, 0x50, 0x4c, 0x41, 0x43, 0x45, 0x5f, 0x4f, 0x4e,
	0x4c, 0x59, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x5f, 0x4f,
	0x4e, 0x4c, 0x59, 0x10, 0x04, 0x2a, 0x45, 0x0a, 0x10, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e,
	0x45, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x45, 0x58, 0x50, 0x45, 0x43, 0x54, 0x5f, 0x47, 0x45,
	0x4e, 0x5f, 0x45, 0x51, 0x55, 0x41, 0x4c, 0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x45, 0x58, 0x50,
	0x45, 0x43, 0x54, 0x5f, 0x47, 0x45, 0x4e, 0x5f, 0x47, 0x54, 0x10, 0x02, 0x2a, 0x30, 0x0a, 0x0b,
	0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x0e, 0x0a, 0x0a, 0x43,
	0x4f, 0x4d, 0x4d, 0x49, 0x54, 0x5f, 0x41, 0x4c, 0x4c, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x43,
	0x4f, 0x4d, 0x4d, 0x49, 0x54, 0x5f, 0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x10, 0x01, 0x32, 0x9d,
	0x0a, 0x0a, 0x03, 0x4b, 0x56, 0x53, 0x12, 0x4f, 0x0a, 0x03, 0x50, 0x75, 0x74, 0x12, 0x29, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x50, 0x75,
	0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x45, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x00, 0x12, 0x4f, 0x0a, 0x03, 0x41, 0x64, 0x64, 0x12, 0x29,
	0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64,
	0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x50,
	0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e,
	0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e,
	0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x00, 0x12, 0x52, 0x0a, 0x06, 0x41, 0x70, 0x70, 0x65,
	0x6e, 0x64, 0x12, 0x29, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x50, 0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x00, 0x12, 0x53, 0x0a, 0x07,
	0x50, 0x72, 0x65, 0x70, 0x65, 0x6e, 0x64, 0x12, 0x29, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x50, 0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x22,
	0x00, 0x12, 0x61, 0x0a, 0x03, 0x47, 0x65, 0x74, 0x12, 0x29, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e,
	0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x2d, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73,
	0x70, 0x69, 0x6b, 0x65, 0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x22, 0x00, 0x12, 0x6d, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x48, 0x65, 0x61, 0x64, 0x65,
	0x72, 0x12, 0x2f, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b,
	0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x47, 0x65, 0x74, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x2d, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69,
	0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70,
	0x69, 0x6b, 0x65, 0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x67, 0x0a, 0x06, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x12, 0x2c, 0x2e,
	0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61,
	0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x45, 0x78,
	0x69, 0x73, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2d, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x45, 0x78, 0x69, 0x73,
	0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x67, 0x0a, 0x06,
	0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x12, 0x2c, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72,
	0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x2d, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73,
	0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f,
	0x73, 0x70, 0x69, 0x6b, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x53, 0x0a, 0x05, 0x54, 0x6f, 0x75, 0x63, 0x68, 0x12, 0x2b,
	0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64,
	0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x54,
	0x6f, 0x75, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x22, 0x00, 0x12, 0x79, 0x0a, 0x0c, 0x42, 0x61,
	0x74, 0x63, 0x68, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x65, 0x12, 0x32, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68,
	0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x33,
	0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64,
	0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x42,
	0x61, 0x74, 0x63, 0x68, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x76, 0x0a, 0x0b, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x49,
	0x6e, 0x64, 0x65, 0x78, 0x12, 0x31, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73,
	0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f,
	0x73, 0x70, 0x69, 0x6b, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x32, 0x2e, 0x63, 0x6f, 0x6d, 0x2e, 0x61, 0x65,
	0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f, 0x6e, 0x2e, 0x41,
	0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x49, 0x6e,
	0x64, 0x65, 0x78, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x70, 0x0a,
	0x09, 0x44, 0x72, 0x6f, 0x70, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x12, 0x2f, 0x2e, 0x63, 0x6f, 0x6d,
	0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d, 0x6f,
	0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x44, 0x72, 0x6f, 0x70, 0x49,
	0x6e, 0x64, 0x65, 0x78, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x30, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x44, 0x72, 0x6f, 0x70,
	0x49, 0x6e, 0x64, 0x65, 0x78, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0x6d, 0x0a, 0x08, 0x54, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x12, 0x2e, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x54, 0x72, 0x75, 0x6e,
	0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2f, 0x2e, 0x63, 0x6f,
	0x6d, 0x2e, 0x61, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x2e, 0x64, 0x61, 0x65, 0x6d,
	0x6f, 0x6e, 0x2e, 0x41, 0x65, 0x72, 0x6f, 0x73, 0x70, 0x69, 0x6b, 0x65, 0x54, 0x72, 0x75, 0x6e,
	0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x0e,
	0x5a, 0x0c, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x3b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_asld_kvs_proto_rawDescOnce sync.Once
	file_asld_kvs_proto_rawDescData = file_asld_kvs_proto_rawDesc
)

func file_asld_kvs_proto_rawDescGZIP() []byte {
	file_asld_kvs_proto_rawDescOnce.Do(func() {
		file_asld_kvs_proto_rawDescData = protoimpl.X.CompressGZIP(file_asld_kvs_proto_rawDescData)
	})
	return file_asld_kvs_proto_rawDescData
}

var file_asld_kvs_proto_enumTypes = make([]protoimpl.EnumInfo, 16)
var file_asld_kvs_proto_msgTypes = make([]protoimpl.MessageInfo, 46)
var file_asld_kvs_proto_goTypes = []interface{}{
	(ParticleType)(0),                     // 0: com.aerospike.daemon.ParticleType
	(ExpType)(0),                          // 1: com.aerospike.daemon.ExpType
	(ExpOp)(0),                            // 2: com.aerospike.daemon.ExpOp
	(ReadModeAP)(0),                       // 3: com.aerospike.daemon.ReadModeAP
	(ReadModeSC)(0),                       // 4: com.aerospike.daemon.ReadModeSC
	(ReplicaPolicy)(0),                    // 5: com.aerospike.daemon.ReplicaPolicy
	(ConsistencyLevel)(0),                 // 6: com.aerospike.daemon.ConsistencyLevel
	(IndexType)(0),                        // 7: com.aerospike.daemon.IndexType
	(IndexCollectionType)(0),              // 8: com.aerospike.daemon.IndexCollectionType
	(AuthMode)(0),                         // 9: com.aerospike.daemon.AuthMode
	(ListOrderType)(0),                    // 10: com.aerospike.daemon.ListOrderType
	(MapOrderType)(0),                     // 11: com.aerospike.daemon.MapOrderType
	(OperationType)(0),                    // 12: com.aerospike.daemon.OperationType
	(RecordExistsAction)(0),               // 13: com.aerospike.daemon.RecordExistsAction
	(GenerationPolicy)(0),                 // 14: com.aerospike.daemon.GenerationPolicy
	(CommitLevel)(0),                      // 15: com.aerospike.daemon.CommitLevel
	(*Expression)(nil),                    // 16: com.aerospike.daemon.Expression
	(*ReadPolicy)(nil),                    // 17: com.aerospike.daemon.ReadPolicy
	(*WritePolicy)(nil),                   // 18: com.aerospike.daemon.WritePolicy
	(*InfoPolicy)(nil),                    // 19: com.aerospike.daemon.InfoPolicy
	(*BatchReadPolicy)(nil),               // 20: com.aerospike.daemon.BatchReadPolicy
	(*BatchWritePolicy)(nil),              // 21: com.aerospike.daemon.BatchWritePolicy
	(*BatchDeletePolicy)(nil),             // 22: com.aerospike.daemon.BatchDeletePolicy
	(*BatchUDFPolicy)(nil),                // 23: com.aerospike.daemon.BatchUDFPolicy
	(*BatchPolicy)(nil),                   // 24: com.aerospike.daemon.BatchPolicy
	(*Bin)(nil),                           // 25: com.aerospike.daemon.Bin
	(*List)(nil),                          // 26: com.aerospike.daemon.List
	(*MapEntry)(nil),                      // 27: com.aerospike.daemon.MapEntry
	(*Map)(nil),                           // 28: com.aerospike.daemon.Map
	(*JsonEntry)(nil),                     // 29: com.aerospike.daemon.JsonEntry
	(*Json)(nil),                          // 30: com.aerospike.daemon.Json
	(*Value)(nil),                         // 31: com.aerospike.daemon.Value
	(*Key)(nil),                           // 32: com.aerospike.daemon.Key
	(*Record)(nil),                        // 33: com.aerospike.daemon.Record
	(*Error)(nil),                         // 34: com.aerospike.daemon.Error
	(*BatchRecord)(nil),                   // 35: com.aerospike.daemon.BatchRecord
	(*CDTContext)(nil),                    // 36: com.aerospike.daemon.CDTContext
	(*Operation)(nil),                     // 37: com.aerospike.daemon.Operation
	(*BatchWrite)(nil),                    // 38: com.aerospike.daemon.BatchWrite
	(*BatchRead)(nil),                     // 39: com.aerospike.daemon.BatchRead
	(*BatchDelete)(nil),                   // 40: com.aerospike.daemon.BatchDelete
	(*BatchUDF)(nil),                      // 41: com.aerospike.daemon.BatchUDF
	(*AerospikeSingleResponse)(nil),       // 42: com.aerospike.daemon.AerospikeSingleResponse
	(*AerospikeGetRequest)(nil),           // 43: com.aerospike.daemon.AerospikeGetRequest
	(*AerospikeGetHeaderRequest)(nil),     // 44: com.aerospike.daemon.AerospikeGetHeaderRequest
	(*AerospikeExistsRequest)(nil),        // 45: com.aerospike.daemon.AerospikeExistsRequest
	(*AerospikeExistsResponse)(nil),       // 46: com.aerospike.daemon.AerospikeExistsResponse
	(*AerospikeDeleteRequest)(nil),        // 47: com.aerospike.daemon.AerospikeDeleteRequest
	(*AerospikeDeleteResponse)(nil),       // 48: com.aerospike.daemon.AerospikeDeleteResponse
	(*AerospikeTouchRequest)(nil),         // 49: com.aerospike.daemon.AerospikeTouchRequest
	(*AerospikePutRequest)(nil),           // 50: com.aerospike.daemon.AerospikePutRequest
	(*BatchOperate)(nil),                  // 51: com.aerospike.daemon.BatchOperate
	(*AerospikeBatchOperateRequest)(nil),  // 52: com.aerospike.daemon.AerospikeBatchOperateRequest
	(*AerospikeBatchOperateResponse)(nil), // 53: com.aerospike.daemon.AerospikeBatchOperateResponse
	(*AerospikeCreateIndexRequest)(nil),   // 54: com.aerospike.daemon.AerospikeCreateIndexRequest
	(*AerospikeCreateIndexResponse)(nil),  // 55: com.aerospike.daemon.AerospikeCreateIndexResponse
	(*AerospikeDropIndexRequest)(nil),     // 56: com.aerospike.daemon.AerospikeDropIndexRequest
	(*AerospikeDropIndexResponse)(nil),    // 57: com.aerospike.daemon.AerospikeDropIndexResponse
	(*AerospikeTruncateRequest)(nil),      // 58: com.aerospike.daemon.AerospikeTruncateRequest
	(*AerospikeTruncateResponse)(nil),     // 59: com.aerospike.daemon.AerospikeTruncateResponse
	(*BackgroundExecutePolicy)(nil),       // 60: com.aerospike.daemon.BackgroundExecutePolicy
	nil,                                   // 61: com.aerospike.daemon.Record.BinsEntry
}
var file_asld_kvs_proto_depIdxs = []int32{
	2,   // 0: com.aerospike.daemon.Expression.cmd:type_name -> com.aerospike.daemon.ExpOp
	31,  // 1: com.aerospike.daemon.Expression.val:type_name -> com.aerospike.daemon.Value
	16,  // 2: com.aerospike.daemon.Expression.bin:type_name -> com.aerospike.daemon.Expression
	1,   // 3: com.aerospike.daemon.Expression.module:type_name -> com.aerospike.daemon.ExpType
	16,  // 4: com.aerospike.daemon.Expression.exps:type_name -> com.aerospike.daemon.Expression
	16,  // 5: com.aerospike.daemon.ReadPolicy.filterExpression:type_name -> com.aerospike.daemon.Expression
	3,   // 6: com.aerospike.daemon.ReadPolicy.readModeAP:type_name -> com.aerospike.daemon.ReadModeAP
	4,   // 7: com.aerospike.daemon.ReadPolicy.readModeSC:type_name -> com.aerospike.daemon.ReadModeSC
	5,   // 8: com.aerospike.daemon.ReadPolicy.replicaPolicy:type_name -> com.aerospike.daemon.ReplicaPolicy
	17,  // 9: com.aerospike.daemon.WritePolicy.policy:type_name -> com.aerospike.daemon.ReadPolicy
	13,  // 10: com.aerospike.daemon.WritePolicy.recordExistsAction:type_name -> com.aerospike.daemon.RecordExistsAction
	14,  // 11: com.aerospike.daemon.WritePolicy.generationPolicy:type_name -> com.aerospike.daemon.GenerationPolicy
	15,  // 12: com.aerospike.daemon.WritePolicy.commitLevel:type_name -> com.aerospike.daemon.CommitLevel
	16,  // 13: com.aerospike.daemon.BatchReadPolicy.filter_expression:type_name -> com.aerospike.daemon.Expression
	3,   // 14: com.aerospike.daemon.BatchReadPolicy.readModeAP:type_name -> com.aerospike.daemon.ReadModeAP
	4,   // 15: com.aerospike.daemon.BatchReadPolicy.readModeSC:type_name -> com.aerospike.daemon.ReadModeSC
	16,  // 16: com.aerospike.daemon.BatchWritePolicy.filter_expression:type_name -> com.aerospike.daemon.Expression
	13,  // 17: com.aerospike.daemon.BatchWritePolicy.RecordExistsAction:type_name -> com.aerospike.daemon.RecordExistsAction
	15,  // 18: com.aerospike.daemon.BatchWritePolicy.commitLevel:type_name -> com.aerospike.daemon.CommitLevel
	14,  // 19: com.aerospike.daemon.BatchWritePolicy.generationPolicy:type_name -> com.aerospike.daemon.GenerationPolicy
	16,  // 20: com.aerospike.daemon.BatchDeletePolicy.filter_expression:type_name -> com.aerospike.daemon.Expression
	15,  // 21: com.aerospike.daemon.BatchDeletePolicy.commitLevel:type_name -> com.aerospike.daemon.CommitLevel
	14,  // 22: com.aerospike.daemon.BatchDeletePolicy.generationPolicy:type_name -> com.aerospike.daemon.GenerationPolicy
	16,  // 23: com.aerospike.daemon.BatchUDFPolicy.filter_expression:type_name -> com.aerospike.daemon.Expression
	15,  // 24: com.aerospike.daemon.BatchUDFPolicy.commitLevel:type_name -> com.aerospike.daemon.CommitLevel
	17,  // 25: com.aerospike.daemon.BatchPolicy.policy:type_name -> com.aerospike.daemon.ReadPolicy
	31,  // 26: com.aerospike.daemon.Bin.value:type_name -> com.aerospike.daemon.Value
	31,  // 27: com.aerospike.daemon.List.l:type_name -> com.aerospike.daemon.Value
	31,  // 28: com.aerospike.daemon.MapEntry.k:type_name -> com.aerospike.daemon.Value
	31,  // 29: com.aerospike.daemon.MapEntry.v:type_name -> com.aerospike.daemon.Value
	27,  // 30: com.aerospike.daemon.Map.m:type_name -> com.aerospike.daemon.MapEntry
	31,  // 31: com.aerospike.daemon.JsonEntry.v:type_name -> com.aerospike.daemon.Value
	29,  // 32: com.aerospike.daemon.Json.j:type_name -> com.aerospike.daemon.JsonEntry
	26,  // 33: com.aerospike.daemon.Value.l:type_name -> com.aerospike.daemon.List
	28,  // 34: com.aerospike.daemon.Value.m:type_name -> com.aerospike.daemon.Map
	30,  // 35: com.aerospike.daemon.Value.json:type_name -> com.aerospike.daemon.Json
	31,  // 36: com.aerospike.daemon.Key.value:type_name -> com.aerospike.daemon.Value
	32,  // 37: com.aerospike.daemon.Record.key:type_name -> com.aerospike.daemon.Key
	61,  // 38: com.aerospike.daemon.Record.Bins:type_name -> com.aerospike.daemon.Record.BinsEntry
	32,  // 39: com.aerospike.daemon.BatchRecord.key:type_name -> com.aerospike.daemon.Key
	33,  // 40: com.aerospike.daemon.BatchRecord.record:type_name -> com.aerospike.daemon.Record
	34,  // 41: com.aerospike.daemon.BatchRecord.error:type_name -> com.aerospike.daemon.Error
	31,  // 42: com.aerospike.daemon.CDTContext.value:type_name -> com.aerospike.daemon.Value
	12,  // 43: com.aerospike.daemon.Operation.opType:type_name -> com.aerospike.daemon.OperationType
	36,  // 44: com.aerospike.daemon.Operation.ctx:type_name -> com.aerospike.daemon.CDTContext
	31,  // 45: com.aerospike.daemon.Operation.binValue:type_name -> com.aerospike.daemon.Value
	35,  // 46: com.aerospike.daemon.BatchWrite.batchRecord:type_name -> com.aerospike.daemon.BatchRecord
	21,  // 47: com.aerospike.daemon.BatchWrite.policy:type_name -> com.aerospike.daemon.BatchWritePolicy
	37,  // 48: com.aerospike.daemon.BatchWrite.ops:type_name -> com.aerospike.daemon.Operation
	35,  // 49: com.aerospike.daemon.BatchRead.batchRecord:type_name -> com.aerospike.daemon.BatchRecord
	20,  // 50: com.aerospike.daemon.BatchRead.policy:type_name -> com.aerospike.daemon.BatchReadPolicy
	37,  // 51: com.aerospike.daemon.BatchRead.ops:type_name -> com.aerospike.daemon.Operation
	35,  // 52: com.aerospike.daemon.BatchDelete.batchRecord:type_name -> com.aerospike.daemon.BatchRecord
	22,  // 53: com.aerospike.daemon.BatchDelete.policy:type_name -> com.aerospike.daemon.BatchDeletePolicy
	35,  // 54: com.aerospike.daemon.BatchUDF.batchRecord:type_name -> com.aerospike.daemon.BatchRecord
	23,  // 55: com.aerospike.daemon.BatchUDF.policy:type_name -> com.aerospike.daemon.BatchUDFPolicy
	31,  // 56: com.aerospike.daemon.BatchUDF.functionArgs:type_name -> com.aerospike.daemon.Value
	34,  // 57: com.aerospike.daemon.AerospikeSingleResponse.error:type_name -> com.aerospike.daemon.Error
	33,  // 58: com.aerospike.daemon.AerospikeSingleResponse.record:type_name -> com.aerospike.daemon.Record
	17,  // 59: com.aerospike.daemon.AerospikeGetRequest.policy:type_name -> com.aerospike.daemon.ReadPolicy
	32,  // 60: com.aerospike.daemon.AerospikeGetRequest.key:type_name -> com.aerospike.daemon.Key
	17,  // 61: com.aerospike.daemon.AerospikeGetHeaderRequest.policy:type_name -> com.aerospike.daemon.ReadPolicy
	32,  // 62: com.aerospike.daemon.AerospikeGetHeaderRequest.key:type_name -> com.aerospike.daemon.Key
	17,  // 63: com.aerospike.daemon.AerospikeExistsRequest.policy:type_name -> com.aerospike.daemon.ReadPolicy
	32,  // 64: com.aerospike.daemon.AerospikeExistsRequest.key:type_name -> com.aerospike.daemon.Key
	34,  // 65: com.aerospike.daemon.AerospikeExistsResponse.error:type_name -> com.aerospike.daemon.Error
	18,  // 66: com.aerospike.daemon.AerospikeDeleteRequest.policy:type_name -> com.aerospike.daemon.WritePolicy
	32,  // 67: com.aerospike.daemon.AerospikeDeleteRequest.key:type_name -> com.aerospike.daemon.Key
	34,  // 68: com.aerospike.daemon.AerospikeDeleteResponse.error:type_name -> com.aerospike.daemon.Error
	18,  // 69: com.aerospike.daemon.AerospikeTouchRequest.policy:type_name -> com.aerospike.daemon.WritePolicy
	32,  // 70: com.aerospike.daemon.AerospikeTouchRequest.key:type_name -> com.aerospike.daemon.Key
	18,  // 71: com.aerospike.daemon.AerospikePutRequest.policy:type_name -> com.aerospike.daemon.WritePolicy
	32,  // 72: com.aerospike.daemon.AerospikePutRequest.key:type_name -> com.aerospike.daemon.Key
	25,  // 73: com.aerospike.daemon.AerospikePutRequest.Bins:type_name -> com.aerospike.daemon.Bin
	39,  // 74: com.aerospike.daemon.BatchOperate.br:type_name -> com.aerospike.daemon.BatchRead
	38,  // 75: com.aerospike.daemon.BatchOperate.bw:type_name -> com.aerospike.daemon.BatchWrite
	40,  // 76: com.aerospike.daemon.BatchOperate.bd:type_name -> com.aerospike.daemon.BatchDelete
	41,  // 77: com.aerospike.daemon.BatchOperate.bu:type_name -> com.aerospike.daemon.BatchUDF
	24,  // 78: com.aerospike.daemon.AerospikeBatchOperateRequest.policy:type_name -> com.aerospike.daemon.BatchPolicy
	51,  // 79: com.aerospike.daemon.AerospikeBatchOperateRequest.records:type_name -> com.aerospike.daemon.BatchOperate
	34,  // 80: com.aerospike.daemon.AerospikeBatchOperateResponse.error:type_name -> com.aerospike.daemon.Error
	35,  // 81: com.aerospike.daemon.AerospikeBatchOperateResponse.records:type_name -> com.aerospike.daemon.BatchRecord
	18,  // 82: com.aerospike.daemon.AerospikeCreateIndexRequest.policy:type_name -> com.aerospike.daemon.WritePolicy
	7,   // 83: com.aerospike.daemon.AerospikeCreateIndexRequest.indexType:type_name -> com.aerospike.daemon.IndexType
	8,   // 84: com.aerospike.daemon.AerospikeCreateIndexRequest.indexCollectionType:type_name -> com.aerospike.daemon.IndexCollectionType
	36,  // 85: com.aerospike.daemon.AerospikeCreateIndexRequest.ctx:type_name -> com.aerospike.daemon.CDTContext
	34,  // 86: com.aerospike.daemon.AerospikeCreateIndexResponse.error:type_name -> com.aerospike.daemon.Error
	18,  // 87: com.aerospike.daemon.AerospikeDropIndexRequest.policy:type_name -> com.aerospike.daemon.WritePolicy
	34,  // 88: com.aerospike.daemon.AerospikeDropIndexResponse.error:type_name -> com.aerospike.daemon.Error
	19,  // 89: com.aerospike.daemon.AerospikeTruncateRequest.policy:type_name -> com.aerospike.daemon.InfoPolicy
	34,  // 90: com.aerospike.daemon.AerospikeTruncateResponse.error:type_name -> com.aerospike.daemon.Error
	5,   // 91: com.aerospike.daemon.BackgroundExecutePolicy.replica:type_name -> com.aerospike.daemon.ReplicaPolicy
	3,   // 92: com.aerospike.daemon.BackgroundExecutePolicy.readModeAP:type_name -> com.aerospike.daemon.ReadModeAP
	4,   // 93: com.aerospike.daemon.BackgroundExecutePolicy.readModeSC:type_name -> com.aerospike.daemon.ReadModeSC
	13,  // 94: com.aerospike.daemon.BackgroundExecutePolicy.recordExistsAction:type_name -> com.aerospike.daemon.RecordExistsAction
	14,  // 95: com.aerospike.daemon.BackgroundExecutePolicy.generationPolicy:type_name -> com.aerospike.daemon.GenerationPolicy
	15,  // 96: com.aerospike.daemon.BackgroundExecutePolicy.commitLevel:type_name -> com.aerospike.daemon.CommitLevel
	31,  // 97: com.aerospike.daemon.Record.BinsEntry.value:type_name -> com.aerospike.daemon.Value
	50,  // 98: com.aerospike.daemon.KVS.Put:input_type -> com.aerospike.daemon.AerospikePutRequest
	50,  // 99: com.aerospike.daemon.KVS.Add:input_type -> com.aerospike.daemon.AerospikePutRequest
	50,  // 100: com.aerospike.daemon.KVS.Append:input_type -> com.aerospike.daemon.AerospikePutRequest
	50,  // 101: com.aerospike.daemon.KVS.Prepend:input_type -> com.aerospike.daemon.AerospikePutRequest
	43,  // 102: com.aerospike.daemon.KVS.Get:input_type -> com.aerospike.daemon.AerospikeGetRequest
	44,  // 103: com.aerospike.daemon.KVS.GetHeader:input_type -> com.aerospike.daemon.AerospikeGetHeaderRequest
	45,  // 104: com.aerospike.daemon.KVS.Exists:input_type -> com.aerospike.daemon.AerospikeExistsRequest
	47,  // 105: com.aerospike.daemon.KVS.Delete:input_type -> com.aerospike.daemon.AerospikeDeleteRequest
	49,  // 106: com.aerospike.daemon.KVS.Touch:input_type -> com.aerospike.daemon.AerospikeTouchRequest
	52,  // 107: com.aerospike.daemon.KVS.BatchOperate:input_type -> com.aerospike.daemon.AerospikeBatchOperateRequest
	54,  // 108: com.aerospike.daemon.KVS.CreateIndex:input_type -> com.aerospike.daemon.AerospikeCreateIndexRequest
	56,  // 109: com.aerospike.daemon.KVS.DropIndex:input_type -> com.aerospike.daemon.AerospikeDropIndexRequest
	58,  // 110: com.aerospike.daemon.KVS.Truncate:input_type -> com.aerospike.daemon.AerospikeTruncateRequest
	34,  // 111: com.aerospike.daemon.KVS.Put:output_type -> com.aerospike.daemon.Error
	34,  // 112: com.aerospike.daemon.KVS.Add:output_type -> com.aerospike.daemon.Error
	34,  // 113: com.aerospike.daemon.KVS.Append:output_type -> com.aerospike.daemon.Error
	34,  // 114: com.aerospike.daemon.KVS.Prepend:output_type -> com.aerospike.daemon.Error
	42,  // 115: com.aerospike.daemon.KVS.Get:output_type -> com.aerospike.daemon.AerospikeSingleResponse
	42,  // 116: com.aerospike.daemon.KVS.GetHeader:output_type -> com.aerospike.daemon.AerospikeSingleResponse
	46,  // 117: com.aerospike.daemon.KVS.Exists:output_type -> com.aerospike.daemon.AerospikeExistsResponse
	48,  // 118: com.aerospike.daemon.KVS.Delete:output_type -> com.aerospike.daemon.AerospikeDeleteResponse
	34,  // 119: com.aerospike.daemon.KVS.Touch:output_type -> com.aerospike.daemon.Error
	53,  // 120: com.aerospike.daemon.KVS.BatchOperate:output_type -> com.aerospike.daemon.AerospikeBatchOperateResponse
	55,  // 121: com.aerospike.daemon.KVS.CreateIndex:output_type -> com.aerospike.daemon.AerospikeCreateIndexResponse
	57,  // 122: com.aerospike.daemon.KVS.DropIndex:output_type -> com.aerospike.daemon.AerospikeDropIndexResponse
	59,  // 123: com.aerospike.daemon.KVS.Truncate:output_type -> com.aerospike.daemon.AerospikeTruncateResponse
	111, // [111:124] is the sub-list for method output_type
	98,  // [98:111] is the sub-list for method input_type
	98,  // [98:98] is the sub-list for extension type_name
	98,  // [98:98] is the sub-list for extension extendee
	0,   // [0:98] is the sub-list for field type_name
}

func init() { file_asld_kvs_proto_init() }
func file_asld_kvs_proto_init() {
	if File_asld_kvs_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_asld_kvs_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Expression); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReadPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WritePolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InfoPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchReadPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchWritePolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchDeletePolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchUDFPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchPolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Bin); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*List); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MapEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Map); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*JsonEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Json); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Value); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Key); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Record); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Error); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchRecord); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CDTContext); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Operation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchWrite); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchRead); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchDelete); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchUDF); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeSingleResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeGetRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeGetHeaderRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeExistsRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeExistsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[31].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeDeleteRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[32].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeDeleteResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[33].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeTouchRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[34].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikePutRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[35].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BatchOperate); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[36].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeBatchOperateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[37].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeBatchOperateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[38].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeCreateIndexRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[39].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeCreateIndexResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[40].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeDropIndexRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[41].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeDropIndexResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[42].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeTruncateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[43].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AerospikeTruncateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_asld_kvs_proto_msgTypes[44].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BackgroundExecutePolicy); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_asld_kvs_proto_msgTypes[0].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[1].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[4].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[5].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[6].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[7].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[8].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[15].OneofWrappers = []interface{}{
		(*Value_Nil)(nil),
		(*Value_I)(nil),
		(*Value_F)(nil),
		(*Value_S)(nil),
		(*Value_B)(nil),
		(*Value_Blob)(nil),
		(*Value_L)(nil),
		(*Value_M)(nil),
		(*Value_Json)(nil),
		(*Value_Geo)(nil),
		(*Value_Hll)(nil),
		(*Value_Wildcard)(nil),
		(*Value_Infinity)(nil),
	}
	file_asld_kvs_proto_msgTypes[16].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[19].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[21].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[26].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[30].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[32].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[35].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[37].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[39].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[41].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[42].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[43].OneofWrappers = []interface{}{}
	file_asld_kvs_proto_msgTypes[44].OneofWrappers = []interface{}{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_asld_kvs_proto_rawDesc,
			NumEnums:      16,
			NumMessages:   46,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_asld_kvs_proto_goTypes,
		DependencyIndexes: file_asld_kvs_proto_depIdxs,
		EnumInfos:         file_asld_kvs_proto_enumTypes,
		MessageInfos:      file_asld_kvs_proto_msgTypes,
	}.Build()
	File_asld_kvs_proto = out.File
	file_asld_kvs_proto_rawDesc = nil
	file_asld_kvs_proto_goTypes = nil
	file_asld_kvs_proto_depIdxs = nil
}
